<!doctype html>
<html class="theme-next use-motion">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>




  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.3.0"/>





    <meta name="keywords" content="Hexo,next" />





    <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.3.0" />




  <title> Hexo </title>
</head>

<body>
  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
    <a href="/" class="brand">
        <span class="logo">
          <i class="icon-logo"></i>
        </span>
        <span class="site-title">Hexo</span>
    </a>
</h1>


  <ul id="menu" class="menu">
    
      
      <li class="menu-item menu-item-home">
        <a href="/">
          <i class="menu-item-icon icon-home"></i> <br />
          首页
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="/archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          归档
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="/tags">
          <i class="menu-item-icon icon-tags"></i> <br />
          标签
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
            
          

          <div id="posts" class="posts-expand">
            
  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2013/07/05/2013-09-05-html5-file/">
                HTML5之文件
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2013-07-05
          
        </span>
        
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <h2 id="写在前面">写在前面</h2><p>项目中有个批量上传照片的需求，我们都知道在xhtml和html4中一个文件上传框只能上传一个文件，我当时使用的是<code>swfupload.js</code>相当方便快捷，且实现了类型筛选、文件大小限制、进度控制、撤销上传等功能，感觉相当不错，推荐给大家。当然了html5让一个文件框可同时上传多个文件，这当然是极好的~</p>
<h2 id="一次上传多个文件">一次上传多个文件</h2><h3 id="multiple属性"><code>multiple</code>属性</h3><p>html5对<code>&lt;input type=&quot;file&quot;&gt;</code>新增了<code>multiple</code>属性。设置了该属性后，一个file框可以同时上传多个文件（在选择文件时ctrl键可用了）。    </p>
<h3 id="file对象"><code>file</code>对象</h3><p>每一个文件都对应一个<code>file</code>对象，文件选择框对应一个<code>files</code>属性，该属性值是一个<code>FileList</code>对象，包含所有的<code>file</code>对象。    </p>
<h3 id="name和lastModifiedDate属性"><code>name</code>和<code>lastModifiedDate</code>属性</h3><p>每一个<code>file</code>对象包含两个属性<code>name</code>和<code>lastModifiedDate</code>。<br><code>name</code>即文件名，不包含路径。  </p>
<p>示例：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type="text/javascript"&gt;</span><br><span class="line">       function check() &#123;</span><br><span class="line">           var files = document.getElementById("test").files;</span><br><span class="line">           for (var i = 0, len = files.length; i &lt; len; i++) &#123;</span><br><span class="line">               alert(files[i].name);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form onsubmit=""&gt;</span><br><span class="line">		&lt;input type="file" id="test" multiple size="100" /&gt;</span><br><span class="line">        &lt;input type="button" onclick="check();"/&gt;</span><br><span class="line">	&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="获取文件大小（size）和类型（type）">获取文件大小（size）和类型（type）</h3><p>上面提到的<code>file</code>对象还有两个属性<code>type</code>和<code>size</code>，这两个属性是继承自Blob对象的。  </p>
<ul>
<li><code>type</code>表示文件的<code>MIME</code>类型  </li>
<li><code>size</code>表示文件的字节长度  </li>
</ul>
<p>示例：  </p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">	&lt;script type="text/javascript"&gt;</span><br><span class="line">        function check() &#123;</span><br><span class="line">            var files = document.getElementById("test").files;</span><br><span class="line">            for (var i = 0, len = files.length; i &lt; len; i++) &#123;</span><br><span class="line">                alert(files[i].type);  </span><br><span class="line">				alert(files[i].size);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">	&lt;body&gt;</span><br><span class="line">	    &lt;form onsubmit=""&gt;</span><br><span class="line">			&lt;input type="file" id="test" multiple size="100" /&gt;</span><br><span class="line">	        &lt;input type="button" onclick="check();"/&gt;</span><br><span class="line">		&lt;/form&gt;</span><br><span class="line">	&lt;/body&gt;    </span><br><span class="line">```  </span><br><span class="line">### 自动筛选特定类型的文件`accept`属性  </span><br><span class="line"></span><br><span class="line">### 给个例子随便感受下：  </span><br><span class="line">```javascript</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Untitled Page&lt;/title&gt;</span><br><span class="line">    &lt;script type="text/javascript"&gt;</span><br><span class="line">        function check() &#123;</span><br><span class="line">            var files = document.getElementById("test").files;</span><br><span class="line">            document.getElementById("num").innerHTML = files.length;</span><br><span class="line">                document.getElementById("info_type").innerHTML = files[0].type;</span><br><span class="line">                document.getElementById("info_size").innerHTML = files[0].size;</span><br><span class="line">                document.getElementById("info_name").innerHTML = files[0].name;</span><br><span class="line">        &#125;</span><br><span class="line">	&lt;/script&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">	&lt;div  style="width:500px; border:1px solid #ccc;padding:10px;"&gt;</span><br><span class="line">	    &lt;form onsubmit=""&gt;</span><br><span class="line">			&lt;input type="file" id="test" multiple size="100" accept="image/*"/&gt;</span><br><span class="line">	        &lt;input type="button" onclick="check();" value="来感受下"/&gt;</span><br><span class="line">		&lt;/form&gt;</span><br><span class="line">		&lt;hr/&gt;</span><br><span class="line">	    &lt;p&gt;文件个数：&lt;span id="num"&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">	    &lt;p&gt;第一个文件类型：&lt;span id="info_type"&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">	    &lt;p&gt;第一个文件字节长度：&lt;span  id="info_size"&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">	    &lt;p&gt;第一个文件名：&lt;span  id="info_name"&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">	&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<h2 id="在前端读取文件内容">在前端读取文件内容</h2><p>HTML5增加了浏览器读取文件内容的功能，通过FileReader对象实现的。读取的结果存放在其<code>result</code>属性中，读取方式有三种：  </p>
<ul>
<li>将文件读取为二进制<code>readAsBinaryString(file)</code>  </li>
<li>将文件读取为文本<code>readAsText(file,encoding)</code>，第二个参数为编码方式，默认为<code>utf-8</code>，若含有中文内容可将该参数设置为<code>GBK</code>  </li>
</ul>
<p>示例：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type="text/javascript"&gt;</span><br><span class="line">       function readText() &#123;</span><br><span class="line">           var files = document.getElementById("test").files;</span><br><span class="line">           var file = files[0];</span><br><span class="line">           var reader = new FileReader();</span><br><span class="line">           reader.readAsText(file,"GBK");</span><br><span class="line">           reader.onload = function () &#123;</span><br><span class="line">               document.getElementById("num").innerHTML = this.result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       function readBS() &#123;</span><br><span class="line">           var files = document.getElementById("test").files;</span><br><span class="line">           var file = files[0];</span><br><span class="line">           var reader = new FileReader();</span><br><span class="line">           reader.readAsBinaryString(file, "GBK");</span><br><span class="line">           reader.onload = function () &#123;</span><br><span class="line">               document.getElementById("num").innerHTML = this.result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;div  style="width:500px; border:1px solid #ccc;padding:10px;"&gt;</span><br><span class="line">    &lt;form onsubmit=""&gt;</span><br><span class="line">		&lt;input type="file" id="test" multiple size="100"/&gt;</span><br><span class="line">        &lt;input type="button" onclick="readText();" value="以文本输出内容"/&gt;</span><br><span class="line">        &lt;input type="button" onclick="readBS();" value="以二进制输出内容"/&gt;</span><br><span class="line">	&lt;/form&gt;&lt;hr/&gt;</span><br><span class="line">    &lt;p&gt;文件内容：&lt;span id="num"&gt;&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">	&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p>

          
        
      </div>
    

    
      <div class="post-footer">
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2013/07/01/2013-09-05-html5-form/">
                HTML5之表单验证
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2013-07-01
          
        </span>
        
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <h2 id="表单的自动验证">表单的自动验证</h2><h3 id="表单元素默认验证">表单元素默认验证</h3><p>HTML5新增了很多表单元素都具有默认验证的功能，<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">	&lt;form action=<span class="string">""</span> id=<span class="string">"my_html5_form"</span> style=<span class="string">"width:300px; border:1px solid #ccc"</span>&gt;</span><br><span class="line">	<span class="xml"><span class="tag">&lt;<span class="title">fieldset</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"email"</span>&gt;</span>电子邮箱email：<span class="tag">&lt;/<span class="title">label</span>&gt;</span><span class="tag">&lt;<span class="title">input</span> <span class="attribute">id</span>=<span class="value">"email"</span> <span class="attribute">type</span>=<span class="value">"email"</span>/&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"url"</span>&gt;</span>个人网站url：<span class="tag">&lt;/<span class="title">label</span>&gt;</span><span class="tag">&lt;<span class="title">input</span> <span class="attribute">id</span>=<span class="value">"url"</span> <span class="attribute">type</span>=<span class="value">"url"</span> /&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">label</span> <span class="attribute">for</span>=<span class="value">"num"</span>&gt;</span>年龄number：<span class="tag">&lt;/<span class="title">label</span>&gt;</span><span class="tag">&lt;<span class="title">input</span> <span class="attribute">id</span>=<span class="value">"num"</span> <span class="attribute">type</span>=<span class="value">"number"</span> <span class="attribute">min</span>=<span class="value">"18"</span> <span class="attribute">max</span>=<span class="value">"30"</span> <span class="attribute">value</span>=<span class="value">"20"</span> <span class="attribute">step</span>=<span class="value">"2"</span>/&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"submit"</span>/&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;/<span class="title">fieldset</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">form</span>&gt;</span>  </span><br><span class="line">```  </span><br><span class="line">在以上代码中使用了html5新增`<span class="tag">&lt;<span class="title">input</span>&gt;</span>`类型中的三个：email、number、url。在表单提交时候，会自动对其输入合法性进行判断，不同浏览器给出提示样式不同。     </span><br><span class="line">   </span><br><span class="line">最好使用Opera（目前Opera对HTML5的支持是最好的），请随意感受下html5默认的输入合法性验证.  </span><br><span class="line"></span><br><span class="line">### 使用表单元素属性进行验证  </span><br><span class="line">HTML5新增了很多表单元素的属性，有form、formmethod、formaction、placeholder、autofocus、list、pattern、required、min、max、step等。这里主要说一下用于表单验证的pattern、required、min、max、step属性。  </span><br><span class="line">  </span><br><span class="line">- pattern属性，对所有类型的`<span class="tag">&lt;<span class="title">input</span>&gt;</span>`元素使用该属性，其值为正则表达式，表单提交时进行验证是否符合设置的正则表达式    </span><br><span class="line">- required属性，对所有类型的`<span class="tag">&lt;<span class="title">input</span>&gt;</span>`元素使用该属性，在提交表单时若设置该属性的`<span class="tag">&lt;<span class="title">input</span>&gt;</span>`元素为空则提示，不允许提交  </span><br><span class="line">- min、max属性适用于`number、range`数值类型以及`date pickers`日期类型的`<span class="tag">&lt;<span class="title">input</span>&gt;</span>`元素，限制输入的最大、最小值，也是在表单提交时进行验证  </span><br><span class="line">- step指定了数值增加的幅度，对于`<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"number"</span> <span class="attribute">min</span>=<span class="value">"0"</span> <span class="attribute">max</span>=<span class="value">"20"</span> <span class="attribute">step</span>=<span class="value">"2"</span>/&gt;</span>`若输入奇数，则表单提交时提示输入不合法。  </span><br><span class="line">  </span><br><span class="line">```javascript  </span><br><span class="line">		<span class="tag">&lt;<span class="title">form</span> <span class="attribute">action</span>=<span class="value">""</span> <span class="attribute">style</span>=<span class="value">"width:400px; border:1px solid #ccc;padding-left:10px;"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">label</span>&gt;</span>required属性：<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">		    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">required</span> <span class="attribute">placeholder</span>=<span class="value">"强制不能为空"</span> <span class="attribute">size</span>=<span class="value">"20"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="title">p</span>&gt;</span>    </span><br><span class="line">		</span><br><span class="line">		<span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">label</span>&gt;</span>pattern属性：<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">		    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"email"</span> <span class="attribute">pattern</span>=<span class="value">"\d"</span>/&gt;</span><span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"ps"</span>&gt;</span><span class="tag">&lt;<span class="title">sapn</span> <span class="attribute">style</span>=<span class="value">"font-size:13px;color:red;"</span>&gt;</span>（若input类型为email，则要先进行email合法判断，再进行pattern设置的判断）<span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="title">p</span>&gt;</span>   </span><br><span class="line">		<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"submit"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="title">form</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="title">form</span> <span class="attribute">action</span>=<span class="value">""</span> <span class="attribute">style</span>=<span class="value">"width:400px; border:1px solid #ccc;padding-left:10px;"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">label</span>&gt;</span>required属性：<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">		    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">required</span> <span class="attribute">placeholder</span>=<span class="value">"强制不能为空"</span> <span class="attribute">size</span>=<span class="value">"20"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="title">p</span>&gt;</span>    </span><br><span class="line">		</span><br><span class="line">		<span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">label</span>&gt;</span>pattern属性：<span class="tag">&lt;/<span class="title">label</span>&gt;</span></span><br><span class="line">		    <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"email"</span> <span class="attribute">pattern</span>=<span class="value">"\d"</span>/&gt;</span><span class="tag">&lt;<span class="title">span</span> <span class="attribute">class</span>=<span class="value">"ps"</span>&gt;</span><span class="tag">&lt;<span class="title">sapn</span> <span class="attribute">style</span>=<span class="value">"font-size:13px;color:red;"</span>&gt;</span>（若input类型为email，则要先进行email合法判断，再进行pattern设置的判断）<span class="tag">&lt;/<span class="title">span</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="title">p</span>&gt;</span>   </span><br><span class="line">		<span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"submit"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">form</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="显示验证（checkValidity()和validity属性）">显示验证（checkValidity()和validity属性）</h3><p>html5中 ，form元素和input元素都有一个<code>checkValidity</code>方法和<code>validity</code>属性。  </p>
<ul>
<li>checkValidity()显示对整个form或者单个表单元素进行合法性判断 ，返回值为true或false，示例：  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">		var email = document.getElementById("email");</span><br><span class="line">		alert(email.checkValidity());  </span><br><span class="line">```  </span><br><span class="line">- validity属性，其值是一个ValidityState对象类型，可通过`node.validity.valid`进行判断合法性，其数据结构如下： </span><br><span class="line"> </span><br><span class="line">	![参数为DOM对象时jQuery对象内部结构](/images/validity.PNG)  </span><br><span class="line">  </span><br><span class="line">### 取消表单验证  </span><br><span class="line">关于取消表单验证，html5新增了一些属性：    </span><br><span class="line"></span><br><span class="line">- form元素的novalidity属性，设置为`true`后提交时对整个表单都不再进行验证  </span><br><span class="line">- 单个input元素的formnovalidity属性，设置为`true`后提交表单时对单个元素取消验证  </span><br><span class="line">- submit元素的formnovalidity属性，设置为`true`后提交表单后取消对整个表单的验证  </span><br><span class="line"></span><br><span class="line">### 自定义提示信息  </span><br><span class="line">当表单的输入不合法时，浏览器有默认的提示信息，可以通过input元素的`setCustomValidity()`进行自定义提示信息。示例：  </span><br><span class="line">```javascript   </span><br><span class="line">	&lt;script type="text/javascript"&gt;</span><br><span class="line">		 function check() &#123;</span><br><span class="line">            var required_text = document.getElementById("test");</span><br><span class="line">            if (!(required_text.checkValidity())) &#123;</span><br><span class="line">                required_text.setCustomValidity("大爷，填上吧！");</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	&lt;/script&gt;</span><br><span class="line">	&lt;form&gt;</span><br><span class="line">		&lt;form onsubmit=""&gt;</span><br><span class="line">		&lt;input type="text" id="test" required /&gt;</span><br><span class="line">        &lt;input type="button" onclick="check();"value="修改提示信息"/&gt;</span><br><span class="line">        &lt;input type="submit" /&gt;</span><br><span class="line">	&lt;/form&gt;</span><br><span class="line">	&lt;/form&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>请找个高端浏览器(Opera、Chrome较高版本)随意感受一下</p>

          
        
      </div>
    

    
      <div class="post-footer">
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2013/06/21/2014-09-01-scope-chain/">
                js中预编译与作用域链
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2013-06-21
          
        </span>
        
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <h2 id="写在前面">写在前面</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> val=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">	alert(val);<span class="comment">//undefined</span></span><br><span class="line">	<span class="keyword">var</span> val=<span class="number">10</span>;</span><br><span class="line">	alert(val);<span class="comment">//10</span></span><br><span class="line">&#125;</span><br><span class="line">alert(val)<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>原以为自己对于js的词法作用域理解的还不错，直到遇到一大波类似于上述的奇奇怪怪的现象后，我就有些凌乱了，成果如下：  </p>
<h2 id="作用域">作用域</h2><h3 id="变量作用域">变量作用域</h3><p>变量作用域scope可以理解为能够访问到这个变量的所有区域，例如可以在全局范围内访问到全局变量，那么全局变量的scope就是全局作用域。  </p>
<h3 id="函数作用域">函数作用域</h3><p>对于函数来讲，任何在函数内部定义的变量、函数的参数、在函数内定义的其他函数都是<strong>局部变量</strong>。只有在函数的内部才能访问到这些局部变量。<br><strong>函数作用域</strong>：函数的内部变量其scope是这个函数体以及这个函数体内嵌套的任意函数体内部。<br><strong>声明提前：</strong>由函数作用域知内部变量在函数体内任何位置都是可访问的，这就导致有可能变量在声明前就是可访问的。在js中函数内声明的所有变量其声明过程都被<strong>提前</strong>到函数体的顶部，而赋值过程仍在代码中原位置。这时由JS引擎的“预编译”导致的。<br><strong>内部变量的优先级：</strong>同名的内部变量的优先级要高于全局变量，这也可由作用域链可知。  </p>
<h3 id="js的词法作用域链">js的词法作用域链</h3><p>当函数在<strong>定义</strong>时，就保存了一个<strong>作用域链</strong>。作用域链确保了可访问的变量和函数，以及访问顺序。作用域链式在代码<strong>定义时</strong>就已确定的，而不是等到执行时才确定。    </p>
<h3 id="变量解析">变量解析</h3><p>沿着作用域链前端的第一个对象开始查找，一旦找到就返回。    </p>
<h2 id="预编译">预编译</h2><h3 id="对预编译的理解">对预编译的理解</h3><p>js在执行前会对代码进行<strong>预编译</strong>，关于预编译需要注意几点：     </p>
<ul>
<li><strong>预编译</strong>工作范围：对var变量声明、以及<code>function(){}</code>函数体内的代码进行处理，并不进行赋值操作。赋值操作发生在执行阶段。举例说明三种情况：    <ul>
<li><code>var val=1;</code>预编译只做了声明的工作即<code>var val;</code>  </li>
<li><code>function f(){/函数体代码段}</code>遇到这样的函数定义，会对函数体内代码段进行预编译  </li>
<li><code>var f=function(){//函数体代码段}</code>这种情况严格意义上讲不属于函数定义，称为对变量f进行声明和初始化比较合适，因此预编译只进行变量f的声明即<code>var f;</code>，对匿名函数体内代码段不进行预编译。  </li>
</ul>
</li>
</ul>
<ul>
<li><p>js的代码是<strong>顺序分块</strong>进行<strong>预编译-执行</strong> 的过程的。顺序是指按照代码定义顺序从上到下进行，分块是针对有多个<code>&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</code>块时，按顺序将第一个<code>&lt;script&gt;&lt;/script&gt;</code>块内代码预编译然后执行，再对下一个<code>&lt;script&gt;&lt;/script&gt;</code>重复该<strong>预编译-执行</strong>的过程。    </p>
</li>
<li><p>由上条可知，当有多个代码块时，后面出现的<code>&lt;script&gt;&lt;/script&gt;</code>代码块能够访问前面出现的<code>&lt;script&gt;&lt;/script&gt;</code>代码块内的全局变量，反过来则不行。    </p>
</li>
<li><p>对函数内部代码进行预编译时，会忽略逻辑判断。例如<code>if(false){var val=1;}</code>仍然会进行<code>var val;</code>预编译。</p>
</li>
</ul>
<h3 id="对预编译、执行、作用域链之间关系的理解">对预编译、执行、作用域链之间关系的理解</h3><p>其实对《Javascript权威指南》和《javascript高级程序设计》里面关于这些的讲解总觉得特别抽象，看完也觉得不知道内部实现机制。自己的理解不知道是否完全正确，但是总能解释下面奇怪的例子们~<br><strong>板板的理解：</strong>在定义函数时就为其保存了一个作用域链，预编译完成后对该作用域链进行修改，在代码的执行过程中也会对其进行修改。看示例一：  </p>
<h4 id="示例一：">示例一：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">(o)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> x = <span class="number">4</span>;</span><br><span class="line">       alert(i);</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">typeof</span> o == <span class="string">"object"</span>) &#123;</span><br><span class="line">           <span class="keyword">var</span> i = <span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">b</span><span class="params">(r)</span> </span>&#123;</span><br><span class="line">               y = <span class="number">5</span>;</span><br><span class="line">           alert(i);</span><br><span class="line">       &#125;;</span><br><span class="line">       b(<span class="number">40</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   a(<span class="number">10</span>);<span class="comment">//undefined、undefined</span></span><br><span class="line">a(&#123;&#125;);<span class="comment">//undefined、2</span></span><br></pre></td></tr></table></figure>
<p>上述代码在预编译完成后期作用域链如下图所示：<br><img src="/images/scope_chain1.PNG" alt="参数为DOM对象时jQuery对象内部结构"><br>由上图可以看出，在预编译完成后，代码执行前，各变量已经是可访问的，只是未赋值。<br>在代码执行过程中，会动态改变作用域链，例如，我们可以画出调用<code>a(10)</code>代码执行到第一个<code>alert(i)</code>时的作用域链：<br>  <img src="/images/scope_chain2.PNG" alt="参数为DOM对象时jQuery对象内部结构"><br>由上图可知：<br>b()的作用域链为：b()的变量对象-》a()的变量对我-》window全局变量对象<br>a()的作用域链为：a()的变量对象-》window全局变量对象<br>window的作用域链为：window全局变量对象<br><strong>在变量解析过程中，</strong>只能<strong>从下到上</strong>在其作用域链上进行搜索。  </p>
<p><code>a(10);</code>调用过程：遇到第一个<code>alert(i)</code>，在a()变量对象中搜索i，搜索到了，其值为undefined，由于未满足if条件，故没能进行赋值操作，i值不变；遇到第二个<code>alert(i)</code>时，在b()变量对象中未搜索i，就沿着作用域链向上搜索到a()变量对象，搜索到i，此时其值为undefined。<br><code>a({})</code>调用过程：遇到第一个<code>alert(i)</code>，在a()变量对象中搜索到i即刻停止搜索，其值为undefined，进行if判断满足，对i进行赋值2；调用b，进行到第二个<code>alert(i)</code>时，在b()变量对象中未搜多到i，沿着作用域链向上搜索到a()变量对象，找到i，其值为2.  </p>
<h4 id="示例二：来说明在预编译时对函数的两种定义的区别对待">示例二：来说明在预编译时对函数的两种定义的区别对待</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">	test1(); <span class="comment">//undefined</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">		alert(<span class="keyword">typeof</span> test2);</span><br><span class="line">    &#125;</span><br><span class="line">    test1();<span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> test2 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        alert(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	test1(); <span class="comment">//3    </span></span><br><span class="line">``` </span><br><span class="line">从上面代码可看出，函数test2是以变量赋值的方法进行定义的，这样预编译时仅进行`<span class="keyword">var</span> test2;`而不管其代码段，test2的值为<span class="literal">undefined</span>。这样在第一次和第二次test1()时可以访问test2，但其值为<span class="literal">undefined</span>，这时候执行test2会报错。而按照test1()方式定义的函数在其所在环境内任何地方都是可以执行的。    </span><br><span class="line"></span><br><span class="line">#### 示例三：  </span><br><span class="line">```javascript</span><br><span class="line">	<span class="keyword">var</span> val=<span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		alert(val)</span><br><span class="line">		val=<span class="number">10</span>;</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">val</span><span class="params">()</span></span>&#123;</span><br><span class="line">		&#125;</span><br><span class="line">		alert(val);</span><br><span class="line">		alert(<span class="keyword">typeof</span> val);</span><br><span class="line">	&#125;  </span><br><span class="line">	test();<span class="comment">//一次弹出undefined、10、number/function</span></span><br><span class="line">	alert(val);<span class="comment">//1</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">#### 示例四：重复声明变量不会影响原来的值  </span><br><span class="line">```javascript  </span><br><span class="line">	<span class="keyword">var</span> i=<span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">var</span> i;</span><br><span class="line">		alert(i);</span><br><span class="line">    &#125;</span><br><span class="line">    test1();  <span class="comment">//10</span></span><br><span class="line">	alert(i);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>由上述代码可以发现，重复声明不会影响变量原来的值。个人理解原因如下：在预编译过程中，进行了两次<code>var i;</code>，就可以说为test1()的变量对象添加了两次i属性，由于同名属性会进行覆盖，因此最终test1()的变量对象只有一个i属性(我认为两个i指向同一个内存块)。那再进行执行的时候，<code>var i=10;</code>为test1()的变量对象的i属性赋值为10，<code>var i;</code>没有赋值，因此最终test1()变量对象的i属性值就为10.作用域链如下图：<br><img src="/images/scope_chain3.PNG" alt="参数为DOM对象时jQuery对象内部结构"></p>
<h4 id="示例四：证实预编译-执行过程是按&lt;script&gt;&lt;/script&gt;块进行的">示例四：证实<strong>预编译-执行</strong>过程是按<code>&lt;script&gt;&lt;/script&gt;</code>块进行的</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">	test()<span class="comment">//出错  </span></span><br><span class="line">	<span class="keyword">var</span> i=<span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">		i=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	f();</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="title">script</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	alert(i)<span class="comment">//2</span></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>由以上代码可知，在第一个<code>&lt;sctipt&gt;</code>块调用第二个代码块中函数会出错，这是由于第二个<code>&lt;script&gt;</code>还未进行预编译，是不可访问到的。第二个代码块可以访问到第一个代码块的全局变量，是因为此时第一个代码块已经预编译切执行结束了.</p>
<h4 id="示例五:预编译时会忽略逻辑判断">示例五:预编译时会忽略逻辑判断</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">var</span> foo=<span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!foo)&#123;</span><br><span class="line">			<span class="keyword">var</span> foo=<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		alert(foo);</span><br><span class="line">	&#125;  </span><br><span class="line">	test()<span class="comment">//2  </span></span><br><span class="line">``` </span><br><span class="line">在预编译结束后,上述代码中test()的变量对象的foo属性为<span class="literal">undefined</span>，因此，执行时<span class="keyword">if</span>(!foo)判断为真。这样就好像在执行时foo的声明提前了。</span><br><span class="line">     </span><br><span class="line">#### 实例六   </span><br><span class="line">```javascript  </span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(val)</span></span>&#123;</span><br><span class="line">		<span class="keyword">var</span> val=<span class="number">10</span>;</span><br><span class="line">		alert(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	f(<span class="number">1</span>)<span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<p>由实例四可知参数val和内部重复定义的val在预编译时指向同一块内存，进行两次赋值后其值为10；还要注意函数的arguments值永远和对应命名参数的值保持一致，任何一方改变都会体现在另一方，但是要知道它们内存空间是独立的。  </p>

          
        
      </div>
    

    
      <div class="post-footer">
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2013/06/13/2013-09-01-browser-kernel/">
                浏览器内核简介
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2013-06-13
          
        </span>
        
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <h2 id="主流浏览器内核">主流浏览器内核</h2><p>浏览器内核又叫渲染引擎、解释引擎、排版引擎等。浏览器内核就是来渲染网页内容的，将页面代码转化为最终看到的页面。浏览器之间之所以存在不兼容的问题就算因为他们的渲染引擎不同。  </p>
<h3 id="1-_Trident内核">1. Trident内核</h3><p>即IE浏览器使用的内核，就是通常所说的IE内核。360浏览器、百度浏览器、搜狗浏览器的新版本都是采用”双核”或”多核”，其中兼容模式使用的即Trident内核，而高速模式使用的大多是Webkit内核。  </p>
<h3 id="2-_Gecko内核">2. Gecko内核</h3><p>目前最主流的Gecko浏览器是FireFox。  </p>
<h3 id="3-_KHTML">3. KHTML</h3><p>Konqueror是一款基于KHTML引擎的浏览器，只能在Linux中使用。</p>
<h3 id="4-_Webkit内核">4. Webkit内核</h3><p>由KHTML内核发展而来，对W3C标准支持的很完善。常见的Webkit浏览器有Chrome、Safari、Android手机浏览器等。  </p>
<h3 id="5-_Presto内核">5. Presto内核</h3><p>是Opera7.0及以后版本使用的内核，Opera之前的版本使用的内核是Elekra。<br>在Opera8及以前版本，其用户代理字符串时最符合规定的，使用产品名和版本号标识自身；在Opera8以后的版本中开始修改用户代理字符串：要么把自己标识成IE和Firefox，要么完全隐藏自身装扮成IE和Firefox。  </p>
<p>进行搜索引擎检测时，要<strong>注意检测顺序</strong>。Opera总是伪装成其他浏览器，所以先检测Opera；Webkit引擎的用户代理字符串包含”Gecko”和”KHTML”，所以要先检测Webkit，后检测Gecko和KHTML；KHTML用户代理字符串中有Gecko字符串，所以先检测KHTML后检测Gecko；最后检测IE。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测搜索引擎</span></span><br><span class="line">   <span class="keyword">var</span> client = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> engine = &#123;</span><br><span class="line">          ie: <span class="number">0</span>,</span><br><span class="line">          gecko: <span class="number">0</span>,</span><br><span class="line">          khtml: <span class="number">0</span>,</span><br><span class="line">	webkit: <span class="number">0</span>,</span><br><span class="line">          opera: <span class="number">0</span>,</span><br><span class="line">          ver: <span class="literal">null</span></span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">var</span> ua = navigator.userAgent;</span><br><span class="line">      <span class="comment">//检测opera</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">window</span>.opera) &#123;</span><br><span class="line">          engine.ver = <span class="built_in">window</span>.opera.version();</span><br><span class="line">          engine.opera = <span class="built_in">parseFloat</span>(engine.ver);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//检测webkit</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/AppleWebKit\/(\S+)/</span>.test(ua)) &#123;</span><br><span class="line">          alert(<span class="number">1</span>);</span><br><span class="line">          engine.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">          engine.webkit = <span class="built_in">parseFloat</span>(engine.ver);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//检测KHTML  </span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/KHTML\/(\S+)/</span>.test(ua) || <span class="regexp">/Konqueror\/([^;]+)/</span>.test(ua)) &#123;</span><br><span class="line">          engine.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">          engine.khtml = <span class="built_in">parseFloat</span>(engine.ver);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//检测Gecko  </span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/rv:([^\)]+)\) Gecko\/\d&#123;8&#125;/</span>.test(ua)) &#123;</span><br><span class="line">          engine.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">          engine.gecko = <span class="built_in">parseFloat</span>(engine.ver);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//检测IE</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/MSIE ([^;]+)/</span>.test(ua)) &#123;</span><br><span class="line">          engine.ver = <span class="built_in">RegExp</span>[<span class="string">"$1"</span>];</span><br><span class="line">          engine.ie = <span class="built_in">parseFloat</span>(engine.ver);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> &#123; engine: engine &#125;;</span><br><span class="line">  &#125; ();</span><br></pre></td></tr></table></figure></p>

          
        
      </div>
    

    
      <div class="post-footer">
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2013/06/02/2014-08-31-object2/">
                js对象相关之二（继承）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2013-06-02
          
        </span>
        
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <h2 id="继承（原型链）">继承（原型链）</h2><p>  在js中继承主要是靠原型链实现的。<br>在js中，创建一个函数（包括构造函数），就为该函数赋一个prototype原型属性，该属性指向原型对象。该原型属性默认获得 一个constructor属性，指回构造函数，原型属性还继承了Object的属性和方法（toString，valueOf等）。通过该构造函数创建的所有实例都有一个[[prototype]]属性，指向原型对象。这样原型中所有的属性和方法就为所有实例共享。  </p>
<h3 id="原型链继承">原型链继承</h3><p>从以上所说的构造函数、原型对象、实例之间的关系就很好理解原型链继承。原型链继承实质就是使一个对象B的原型对象为另一个对象A的实例。这样对象B的实例指向B的原型对象，B的原型对象又指向A的原型对象，形成了原型链，而B的实例也继承了原型链上的所有属性和方法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//基类	</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name,interests)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name=name;</span><br><span class="line">		<span class="keyword">this</span>.interests=interests;</span><br><span class="line">	&#125;</span><br><span class="line">	Person.prototype.say=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;alert(<span class="string">"hello"</span>);&#125;;</span><br><span class="line">	<span class="comment">//子类	</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	Student.prototype=<span class="keyword">new</span> Person(<span class="string">"zc"</span>,[<span class="string">"reading"</span>,<span class="string">"dancing"</span>]);  </span><br><span class="line">	<span class="keyword">var</span> student=<span class="keyword">new</span> Student();  </span><br><span class="line">``` </span><br><span class="line">**原型链的缺点：**  </span><br><span class="line">  </span><br><span class="line">- 通过子类从基类中继承来的所有属性（不管是实例属性还是原型属性）都变成了子类的原型属性。当含有引用类型的属性时，子类创造的所有实例对该属性进行共享，那么一个实例中该属性的变化会直接体现在其他属性中。  </span><br><span class="line">- 创建子类实例是不能向构造函数中传参。  </span><br><span class="line"></span><br><span class="line">### 借助构造函数继承  </span><br><span class="line">就是在子类的构造函数内部调用基类的构造函数  </span><br><span class="line">```javascript  </span><br><span class="line">	<span class="comment">//基类	</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name,interests)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name=name;</span><br><span class="line">		<span class="keyword">this</span>.interests=interests;</span><br><span class="line">		<span class="keyword">this</span>.say=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;alert(<span class="string">"hello"</span>);&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//子类  </span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">Student</span><span class="params">(name,interests)</span></span>&#123;</span><br><span class="line">		Person.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> student1=<span class="keyword">new</span> Student(<span class="string">"zc"</span>,[<span class="string">"reading"</span>,<span class="string">"dancing"</span>]);  </span><br><span class="line">``` </span><br><span class="line">**借助构造函数的缺点：**  </span><br><span class="line">  </span><br><span class="line">- 所有的属性和方法必须定义在基类的构造函数中，才能被子类继承，无法达到方法的公用。  </span><br><span class="line"></span><br><span class="line">### 组合继承  </span><br><span class="line">即是将原型链继承和借助构造函数继承结合起来。原型链实现原型属性的继承，借助构造函数实现实例属性的继承。这也是最常用的一种继承方式。</span><br><span class="line"></span><br><span class="line">举个例子说明如何通过原型链和借助构造函数实现继承的，并绘制出了完整的原型链：  </span><br><span class="line">```javascript	  </span><br><span class="line">	<span class="comment">//基类  </span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name,age,interests)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name=name;</span><br><span class="line">		<span class="keyword">this</span>.age=age;</span><br><span class="line">		<span class="keyword">this</span>.interests=interests;</span><br><span class="line">	&#125; </span><br><span class="line">	Person.prototype.species=<span class="string">"人"</span>;</span><br><span class="line">	Person.prototype.sayName=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//派生类  </span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">Student</span><span class="params">(name,age,interests,grade)</span></span>&#123;</span><br><span class="line">		Person.call(<span class="keyword">this</span>,name,age,interests);</span><br><span class="line">		<span class="keyword">this</span>.grade=grade;</span><br><span class="line">	&#125;</span><br><span class="line">	Student.prototype=<span class="keyword">new</span> Person();</span><br><span class="line">	Student.prototype.constructor=Student;  </span><br><span class="line">	Student.prototype.sayGrade=<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">		alert(<span class="keyword">this</span>.grade);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建Student实例  </span></span><br><span class="line">	<span class="keyword">var</span> student1=<span class="keyword">new</span> Student(<span class="string">"张三"</span>,<span class="number">24</span>,[<span class="string">"打球"</span>],<span class="string">"研二"</span>);  </span><br><span class="line">	student1.interests.push(<span class="string">"跳舞"</span>);</span><br><span class="line">	<span class="keyword">var</span> student2=<span class="keyword">new</span> Student(<span class="string">"李四"</span>,<span class="number">23</span>,[<span class="string">"呵呵"</span>,<span class="string">"哈哈"</span>],<span class="string">"博一"</span>);</span><br></pre></td></tr></table></figure></p>
<p>以上代码的完整原型链为：<br><img src="/images/prototype6.PNG" alt="参数为DOM对象时jQuery对象内部结构"><br>由上图可以看出：<br><strong>student1的原型链为(沿红线方向)：</strong><code>student1-&gt;Student.prototype-&gt;Person.prototype-&gt;Object.prototype</code><br>当读取对象student1的属性时，沿着原型链一直找，直到找到返回。    </p>
<p><strong>对象student1的所有属性和方法：</strong>    </p>
<ul>
<li>实例属性：grade、name、age、interests  </li>
<li>引用属性：sayGrade、sayName、constructor、species</li>
</ul>

          
        
      </div>
    

    
      <div class="post-footer">
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2013/06/02/2014-08-31-object1/">
                js对象之一（原型及原型链）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2013-06-02
          
        </span>
        
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <h2 id="写在前面">写在前面</h2><p>下决心整理对象相关，是因为看到下面这个现象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>);<span class="comment">//true  </span></span><br><span class="line">alert(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>虽然知道结果都是<code>true</code>,但是解释原因时觉得一句”一切对象都继承自<code>Oject</code>“显得太过苍白。</p>
<h2 id="原型及原型链">原型及原型链</h2><p><strong>构造函数就是函数！</strong>任何函数通过new操作符调用，那它就是构造函数；任何函数，不通过new来调用，那就和普通的函数没有任何区别。    </p>
<p>任何时候，只要！创建一个函数，就为该函数创建一个属性prototype，指向一个原型对象，<strong>原型对象实质上是对象</strong>，因此是原型对象是Object的实例。而任何函数都是Function的实例。  </p>
<p><strong>构造函数、原型、实例之间的关系图如下所示：</strong><br><img src="/images/prototype1.PNG" alt="参数为DOM对象时jQuery对象内部结构"> </p>
<p><strong>Function、Array、Object</strong>这些构造函数其实质都是 <strong>函数！</strong>那就可以理解为它们是Function的实例;<br><strong>Function.prototype、Array.prototype</strong>这些原型对象归根结底都是对象，因此它们都是Object的实例。<br>由此可以得出下图：  </p>
<p> <img src="/images/prototype2.PNG" alt="参数为DOM对象时jQuery对象内部结构"><br>由上图可以看出（原型链是跟着[[prototype]]走的）：    </p>
<ul>
<li>Function的原型链为：    Function———》Function.prototype ————》Object.prototype    </li>
<li>Object的原型链为：  Object——》Function.prototype ——》Object.prototype  </li>
<li>F的原型链为：F ——》Function.prototype ——》Object.prototype    </li>
<li>f1的原型链为：f1 ——》F.prototype ——》Object.prototype</li>
</ul>
<p>由上可以看出，<strong>任何对象的原型链其根节点都是Object.prototype，这也是为什么说js中任何对象都是继承自Object</strong>。  </p>
<p><strong>操作符instanceof的含义：</strong><br><code>O instanceof F</code> O是对象，F是函数。若O为F的一个实例则返回true，反之返回false。其工作原理为：若在O的原型链中能找到F则返回true。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> f1=<span class="keyword">new</span> F();    </span><br><span class="line">alert(F <span class="keyword">instanceof</span> <span class="built_in">Function</span>)<span class="comment">//true  </span></span><br><span class="line">alert(f1 <span class="keyword">instanceof</span> <span class="built_in">Function</span>)<span class="comment">//false  </span></span><br><span class="line">alert(f1 <span class="keyword">instanceof</span> F)<span class="comment">//true</span></span><br><span class="line">alert(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>)<span class="comment">//true  </span></span><br><span class="line">alert(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>)<span class="comment">//true    </span></span><br><span class="line">alert(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>)<span class="comment">//true  </span></span><br><span class="line">alert(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>)<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p><strong>方法isPrototypeOf()的含义：</strong><br><code>O1.isPrototypeOf(O2)</code>其中O1、O2都是对象。表面含义是若O1是O2的原型对象则返回true。实际上，若对象O2的[[prototype]]属性指向O1则返回true。工作原理为：若能在O2的原型链上找到O1则返回true。因此：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> f1=<span class="keyword">new</span> F();    </span><br><span class="line">alert(<span class="built_in">Object</span>.prototype.isPrototypeOf(<span class="built_in">Function</span>));<span class="comment">//true;</span></span><br><span class="line">alert(<span class="built_in">Function</span>.prototype.isPrototypeOf(<span class="built_in">Function</span>));<span class="comment">//true</span></span><br><span class="line">alert(<span class="built_in">Object</span>.prototype.isPrototypeOf(<span class="built_in">Object</span>));<span class="comment">//true </span></span><br><span class="line">alert(<span class="built_in">Function</span>.prototype.isPrototypeOf(<span class="built_in">Object</span>));<span class="comment">//true </span></span><br><span class="line">alert(<span class="built_in">Object</span>.prototype.isPrototypeOf(f1));<span class="comment">//true</span></span><br><span class="line">alert(F.prototype.isPrototypeOf(f1))<span class="comment">//true;</span></span><br></pre></td></tr></table></figure></p>
<p>最后，附上mollypages.org的一张图，与上图本质上是一样的：<br> <img src="/images/prototype3.PNG" alt="参数为DOM对象时jQuery对象内部结构">   </p>
<h2 id="对象中属性的读取">对象中属性的读取</h2><p>当读取对象的一个属性时，实际是进行了一次<strong>搜索</strong>。搜索先从实例本身开始，若找到则停止搜索返回其值；若未找到，则继续搜索其[[prototype]]指向的原型对象，若找到返回，未找到返回undefined。<br>这也就是为什么不管是先创建实例还是先修改原型，原型的修改都会立即体现在所有实例上。    </p>
<p>可以通过对象实例<strong>访问</strong>原型中的值；<br>当原型中的属性值为引用类型时，可以通过实例进行 <strong>修改</strong>，但这个修改会体现在所有实例上；<br>但是不能通过实例对原型中的值进行 <strong>重写</strong>。当实例中的属性名与原型中属性名相同时，实例中的属性名会 <strong>屏蔽</strong>原型中的该属性，因为 <strong>搜索</strong>提前结束了,也就是说这只会阻止访问原型中的那个值，但不会改变原型中的值。可通过 <strong>delete</strong>操作符删除实例属性，是原型属性重新可访问。看以下示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	F.prototype.arr=[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">var</span> f1=<span class="keyword">new</span> F();</span><br><span class="line">	<span class="keyword">var</span> f2=<span class="keyword">new</span> F();</span><br><span class="line">	<span class="comment">/********修改*********/</span></span><br><span class="line">	f1.arr.push(<span class="number">2</span>);</span><br><span class="line">	alert(f2.arr)<span class="comment">//[1,2]  </span></span><br><span class="line">  	<span class="comment">/*********重写************/</span></span><br><span class="line">	f1.arr=[<span class="number">2</span>];</span><br><span class="line">	alert(f2.arr)<span class="comment">//[1]  </span></span><br><span class="line">```  </span><br><span class="line">**hasOwnProperty()**  </span><br><span class="line">这是对象的一个方法，是从<span class="built_in">Object</span>继承而来的。`O.hasOwnProperty(attr)`判断属性attr是否为对象O的实例属性，是返回<span class="literal">true</span>。实质就是体现是在实例中搜索到的属性attr还是在原型中搜索到的属性attr。  </span><br><span class="line">  </span><br><span class="line">**<span class="keyword">in</span>操作符**    </span><br><span class="line"></span><br><span class="line">- 单独使用时`attr <span class="keyword">in</span> object1`，若能在对象object1中找到属性attr，则返回ture，而不管该属性是否可枚举，是在实例中还是原型中；  </span><br><span class="line">- 使用`<span class="keyword">for</span>-<span class="keyword">in</span>`返回能通过对象访问到的、可枚举的属性，而不管该属性在实例中还是原型中。按照规定，在实例中定义的属性都是可枚举的，包括那些屏蔽了原型中不可枚举的实例属性。但是在IE8及IE8-存在一个bug，即屏蔽了原型中不可枚举的实例属性不会在<span class="keyword">for</span>-<span class="keyword">in</span>中出现。</span><br><span class="line">  </span><br><span class="line">## 重写原型  </span><br><span class="line">**重写原型的后果：**  </span><br><span class="line"><span class="number">1.</span>切断了构造函数与最初原型的关系，构造函数的prototype属性原始指向最初原型，现在被重写指向新原型；  </span><br><span class="line">```javascript	  </span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    F.prototype = &#123; </span><br><span class="line">		constructor:F;</span><br><span class="line">		arr: [<span class="number">1</span>] &#125;;</span><br></pre></td></tr></table></figure></p>
<p>如下图所示：<br><img src="/images/prototype4.PNG" alt="参数为DOM对象时jQuery对象内部结构"><br>2.切断了重写原型前创建的所有实例与新原型的联系，之前的实例仍然指向初始原型。这是由于每次新建实例时，赋给该实例一个[[prototype]]属性，指向当时的原型。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> f1 = <span class="keyword">new</span> F();</span><br><span class="line">   F.prototype = &#123; arr: [<span class="number">1</span>] &#125;;</span><br><span class="line">   <span class="keyword">var</span> f2 = <span class="keyword">new</span> F();</span><br><span class="line">   alert(f2.arr);<span class="comment">//1</span></span><br><span class="line">   alert(f1.arr);  <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p>
<p>如下图所示：<br><img src="/images/prototype5.PNG" alt="参数为DOM对象时jQuery对象内部结构">    </p>

          
        
      </div>
    

    
      <div class="post-footer">
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2013/06/02/2013-08-31-ajax3/">
                Ajax之jQuery对Ajax的封装（之那些被遗忘的参数）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2013-06-02
          
        </span>
        
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <p>  　　</p>
<h2 id="写在前面">　写在前面　　　　</h2><p>在项目开发过程中，在使用jQuery封装的Ajax时遇到过2个问题：  </p>
<ol>
<li>请求数据时，总是读浏览器缓存，即使服务器数据已发生变化  </li>
<li>有时候需要再Ajax回调函数中输出响应主体文本，类似于“操作成功”之类的，但有时候发现输出的居然是网页源代码，这个是session超时导致的。因为这个问题被测试部烦了好久好久好久。。。。这也是下定决心总结下封装Ajax的原因。<br>在下面的总结中将穿插提到这两个问题的原因及解决方法。  </li>
</ol>
<h2 id="丰富的接口">丰富的接口</h2><ul>
<li>底层封装：$.ajax()  </li>
<li>2层封装：$(selector).load()、$.get()、$.post()  </li>
<li>3层封装：$.getScript、$.getJSON()  </li>
</ul>
<h2 id="回调函数中容易被人忽视的参数">回调函数中容易被人忽视的参数</h2><p>关于封装的各个接口的具体使用不再赘述，这里重点讲下回调函数中的各参数。这部分在使用过程中很容易被忽略，大部分人很欢快地使用jquery实现了功能就不管了~</p>
<h3 id="$(selector)-load()">$(selector).load()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#FileApp"</span>).load(<span class="string">'./GetSubstanceInfo'</span>,</span><br><span class="line">                    &#123; <span class="string">'ExaAppId'</span>: ExaAppId &#125;,</span><br><span class="line">                    <span class="function"><span class="keyword">function</span> <span class="params">(responseData, textStatus, XHR)</span> </span>&#123;</span><br><span class="line">                        alert(<span class="keyword">this</span>.id);<span class="comment">//FileApp</span></span><br><span class="line">					<span class="comment">//在该回调函数中，this指向$(#FileApp);</span></span><br><span class="line">					<span class="comment">//responseData 返回的响应主体内容，与XHR.responseText是一致的</span></span><br><span class="line">					<span class="comment">//textStatus http状态：success、error、notmodified、timeout  </span></span><br><span class="line">					<span class="comment">//XHR即当前XMLHttpRequest对象</span></span><br><span class="line">                    &#125;</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p>需要说明，<strong>在load()方法中，无论请求是否成功，只要请求完成，都会触发回调函数</strong>，这样可以在回调函数中检查textStatus就可以知道响应的情况。我觉得最值得欢呼雀跃的是返回了XHR对象，根据XHR对象的各属性及方法就可以为所欲为了<del>~</del>~  </p>
<p>还记得我们上面提到的sesion超时导致ajax返回网页源代码的问题吧。一般情况下，当检测到session超时时，后台的常规处理是是网页跳转到指定页面（例如登录页）。对于ajax请求来说，这时就将指定页面源码当做XHR对象的响应内容返回，于是在回调函数里获取到的其实是指定页面的源码。<br>我的处理是，在后台超时处理时对请求类型进行判断，如果是ajax请求，则为XHR增加一个自定义头部信息，将其值设为<code>timeout</code>，在回调函数中根据XHR对象对这个头部信息进行判断，以做出相应处理。代码如下：  </p>
<pre><code class="javascript">C#部分  
public <span class="keyword">void</span> SetTimeOut()
    {
        string ajaxHeaser = Request.Headers[<span class="string">"x-requested-with"</span>];
        <span class="keyword">if</span> (ajaxHeaser != <span class="literal">null</span> &amp;&amp; ajaxHeaser.ToLower().Equals(<span class="string">"XMLHttpRequest"</span>, StringComparison.OrdinalIgnoreCase))
        {
            <span class="comment">//是ajax请求，添加自定义头部信息sessionstatus</span>
            Response.AppendHeader(<span class="string">"sessionstatus"</span>, <span class="string">"timeout"</span>);
        }
        <span class="keyword">else</span>
        {
            <span class="comment">//不是ajax请求，跳转到指定页面</span>
            Response.Redirect(<span class="string">"~/Home/Login"</span>);
        }

    }  

js部分
$(<span class="string">"#FileApp"</span>).load(<span class="string">'./GetSubstanceInfo'</span>,
                 { <span class="string">'ExaAppId'</span>: ExaAppId },
                 <span class="function"><span class="keyword">function</span> <span class="params">(response, textStatus, XHR)</span> </span>{
                    <span class="keyword">var</span> sessionStatus = XHR.getResponseHeader(<span class="string">"sessionstatus"</span>);
                      <span class="keyword">if</span> (sessionStatus == <span class="string">"timeout"</span>) {
                          <span class="comment">//.....</span>
                      } 
                      <span class="keyword">else</span> {
                          <span class="comment">//......</span>
                      }
                 }
 );
</code></pre>
<h3 id="$-get()">$.get()</h3><pre><code class="javascript">$.get(
        <span class="string">"./GetExamerByDepId"</span>,
        { <span class="string">"DepId"</span>: selected_dep_val },
        <span class="function"><span class="keyword">function</span> <span class="params">(responseData, textStatus, XHR)</span> </span>{
                <span class="comment">//this 该对象包含的是这次ajax请求的配置信息</span>
                <span class="comment">//responseData 响应主体的内容，与XHR.responseText是一致的</span>
                <span class="comment">//textStatus http状态：success、error、notmodified、timeout  </span>
                <span class="comment">//XHR即当前XMLHttpRequest对象</span>

        },
        <span class="string">"text"</span>
    );
</code></pre>
<p>在有些书上说$.get()的回调函数中只有两个参数responseData、textStatus。实际上，还有第三个参数XHR对象。  </p>
<p>在$.get()回调函数内部也有个<code>this</code>对象，其结构如下：<br><img src="/images/ajax1.PNG" alt="参数为DOM对象时jQuery对象内部结构">  </p>
<p>需要注意的是，$.get()中<strong>只有当数据成功返回才调用回调函数。</strong>    </p>
<p>与load()不同的是，$.get()可以返回的数据类型很丰富：xml、html、script、json、text、_default。</p>
<h3 id="$-post()">$.post()</h3><pre><code class="javascript">$.post(
        <span class="string">"./GetExamerByDepId"</span>,
        { <span class="string">"DepId"</span>: selected_dep_val },
        <span class="function"><span class="keyword">function</span> <span class="params">(responseData, textStatus, XHR)</span> </span>{
                <span class="comment">//this 该对象包含的是这次ajax请求的配置信息</span>
                <span class="comment">//responseData 响应主体的内容，与XHR.responseText是一致的</span>
                <span class="comment">//textStatus http状态：success、error、notmodified、timeout  </span>
                <span class="comment">//XHR即当前XMLHttpRequest对象</span>

        },
        <span class="string">"text"</span>
    );
</code></pre>
<p>如果不管post、get在实现上的区别，仅从jQuery封装的角度来看，$.get和$.post在使用上非常类似。<br>同样，其回调函数的参数也有XHR对象。其this对象的结构如下图所示：<br><img src="/images/ajax2.PNG" alt="参数为DOM对象时jQuery对象内部结构">  </p>
<h3 id="$-ajax()">$.ajax()</h3><pre><code class="javascript">$.ajax({
        url: <span class="string">"./CancelPublish"</span>,
        method: <span class="string">"post"</span>,
        cache:<span class="literal">false</span>,
        <span class="comment">//....</span>
        data: { <span class="string">"ExaAppId"</span>: val }, <span class="comment">//向后台传送审批ID  </span>
        beforeSend:<span class="function"><span class="keyword">function</span><span class="params">(XHR)</span></span>{
            <span class="comment">//this 该对象包含的是这次ajax请求的配置信息</span>
        },
        complete:<span class="function"><span class="keyword">function</span><span class="params">(XHR,textStatus)</span></span>{
            <span class="comment">//this 该对象包含的是这次ajax请求的配置信息</span>
        }
        success: <span class="function"><span class="keyword">function</span> <span class="params">(response, textStatus, XHR)</span> </span>{
            <span class="comment">//this 该对象包含的是这次ajax请求的配置信息</span>
        },
        error: <span class="function"><span class="keyword">function</span> <span class="params">(XHR,textStatus,errorThrown)</span> </span>{
            <span class="comment">//this 该对象包含的是这次ajax请求的配置信息</span>
        }
    });
</code></pre>
<p>在项目开发中，我最喜欢用$.ajax()。因为可控性比较大，比如，可以在<code>beforeSend</code>中修改请求头部信息。     </p>
<h3 id="特别说明">特别说明</h3><p>在上述接口中可以看到，不管是回调函数，还是$.ajax()中属性对于函数中都有一个this对象，这个对象包含的是这次ajax请求的配置信息。<br>另外，在load()中我讲到了session超时返回网页源代码的解决，这个不光在load()中适用，在其他几个接口中同样适用。  </p>
<h2 id="缓存问题">缓存问题</h2><p>关于开头提到的缓存问题，其原因是若已经请求过一次，当再次请求时若参数<code>{key1:value1,key2:value2}</code>未发生变化，则不再从后台请求数据，而是直接读取浏览器缓存。<br>解决办法很多，我这里说两个我项目中常用到的：  </p>
<ol>
<li>在<code>$.ajax(options)</code>中，<code>options</code>有个可选属性<code>cache</code>，设为<code>false</code>便不再从浏览器缓存中读数据。  </li>
<li>由于在<code>$.get()、$.post()、$(selector).load()</code>中没有<code>cache</code>属性，则在参数部分增加一个名值对，其值赋为随机数<code>{key1:value1,key2:value2...,random:Math.random()}</code>，这样每次发送的参数都是变化的则会直接请求后台而不是读取缓存。  </li>
</ol>

          
        
      </div>
    

    
      <div class="post-footer">
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2013/06/01/2013-08-30-ajax2/">
                AJAX之头部信息
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2013-06-01
          
        </span>
        
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <h2 id="头部信息">头部信息</h2><p>HTTP的头部信息包括主要请求头部信息和响应头部信息。在IE下可以使用HttpWatch看到每次请求的详细信息，包括请求方式、http响应的状态、耗时以及头部信息。如下图所示：   </p>
<p><img src="/images/httpwatch.PNG" alt="参数为DOM对象时jQuery对象内部结构">    </p>
<p>在Chorme下使用调试工具中的NetWork页可以查看这些信息，如下图所示：    </p>
<p><img src="/images/chromenetwork.PNG" alt="参数为DOM对象时jQuery对象内部结构"> </p>
<ul>
<li>设置请求头部信息（由浏览器发送给服务器）<br>  <code>setRequestHeader(para1,para2)</code>其中para1是头部信息字段，可以是自定义的；para2是要设置的值。  </li>
<li>获取响应头部信息（服务器发回给浏览器）<br>  <code>getResponseHeader(para)</code>其中para是头部信息字段。<br>  <code>getAllResponseHeaders()</code>获取所有头部信息，返回长字符串（多行文本）    </li>
</ul>
<h3 id="请求头部信息（由浏览器发送给服务器）：">请求头部信息（由浏览器发送给服务器）：</h3><ul>
<li>Accept：浏览器能够处理的文本类型，例如<code>application/xml,text/xml,*/*</code>  </li>
<li>Accept-Charset:浏览器能够显示的字符集  </li>
<li>Accept-Encoding：浏览器能够处理的压缩编码，例如<code>gzip,deflate</code>,  </li>
<li>Accept-Language：浏览器当前设置的语言，例如<code>zh-cn</code>  </li>
<li>Host：发出请求的页面所在域  </li>
<li>Cookie：当前页面设置的任何Cookie  </li>
<li>Referer：发出请求的页面的URI  </li>
<li>User-Agent:浏览器的用户代理字符串  </li>
</ul>
<h3 id="通用头部信息（请求和响应头部都可能包含）：">通用头部信息（请求和响应头部都可能包含）：</h3><ul>
<li>Cache-Control：缓存机制    </li>
<li>Connect：是否持久连接。值Close、Keep-Alive  </li>
<li>Date：消息发送的时间  </li>
</ul>
<h3 id="响应头部信息（由服务器发回给浏览器）">响应头部信息（由服务器发回给浏览器）</h3><ul>
<li>Server：服务器表明自己的版本等信息  </li>
</ul>
<h3 id="实体头部信息（与响应实体相关的信息）">实体头部信息（与响应实体相关的信息）</h3><ul>
<li>Content-Length：服务器告诉浏览器响应的实体的长度  </li>
<li>Content-Type：服务器告诉浏览器响应的实体对象的类型   </li>
<li>Etag:文件的标志值，当服务器上文件修改时，这个值也会改变。浏览器再次请求该文件时，会将Etag值发给服务器，服务器将这个值跟当前的Etag值对比，若未发生变化，则读取缓存304.  </li>
<li>Last-Modified：服务器认为文件最后修改时间  </li>
<li>Expires：服务器认为实体对象的过期时间  </li>
</ul>

          
        
      </div>
    

    
      <div class="post-footer">
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2013/05/28/2013-08-28-vertical-and-center/">
                css居中
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2013-05-28
          
        </span>
        
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <h2 id="居中">居中</h2><h3 id="水平居中_：">水平居中  ：</h3><ul>
<li><p>行内元素的水平居中：图片、文本等水平居中：<br>给其父元素设置<code>text-align:center;</code>    </p>
<pre><code class="css">      CSS:    
      .father{
           border:1px solid blue;
           width:200px;height:100x;
           text-align:center;}
      HTML:
      &lt;div class="father"&gt;
          &lt;span style=""&gt;居中文本&lt;/span&gt;
      &lt;/div&gt;  

  &lt;div style="border:1px solid blue;width:200px;height:100x;text-align:center;"&gt;  
&lt;span style=""&gt;居中文本&lt;/span&gt;
&lt;/div&gt;
</code></pre>
</li>
<li><p>确定宽度的块级元素的水平居中：<br>设置该块级元素<code>margin-left:auto;margin-right:auto;</code>    </p>
<pre><code class="css">    CSS:  
    .father{
            width:200px;
            height:100px;
            border:1px solid green;
        }
    .cur{
            width:100px;
            height:100px;
            margin:0 auto;
        }
    HTML:
    &lt;div class="father"&gt;
        &lt;div class="cur"&gt;块级水平居中    
        &lt;/div&gt;
    &lt;/div&gt;    

&lt;div class="father" style="width:200px;border:1px solid green;"&gt;
    &lt;div class="cur" style="width:100px;margin:0 auto;"&gt;块级水平居中    
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
</li>
<li><p>不确定宽度的块级元素的水平居中：      </p>
<ul>
<li><p>方法一：将该块级元素设置<code>display:inline-block;</code>，再对其父元素设置<code>text-align:center;</code>  </p>
<pre><code>CSS:  
.father{
        width:<span class="number">200</span>px;
        border:<span class="number">1</span>px solid green;
        <span class="type">text</span>-align:center;
    }
.cur{
        display:inline;
    }
HTML:
&lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"father"</span>&gt;
    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"cur"</span>&gt;块级水平居中    
    &lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;        
</code></pre>  <div class="father" style="width:200px;border:1px solid green;text-align:center;"><br>      <div class="cur" style="display:inline;">块级水平居中<br>      </div><br>  </div>    </li>
<li>方法二：借助table布局。<br>将需要居中的元素写在table里，然后对table设置<code>margin-left:auto;margin-right:auto;</code>。    </li>
<li><p>方法三：设置<code>position、left</code>正负抵消，达到居中水平效果。  </p>
<pre><code>CSS<span class="value">:      
/*father设置relative是为了helpdiv移动时以father为参照*/
.father{width:<span class="number">200px</span>;</span><span class="attribute">height</span><span class="value">:<span class="number">200px</span>;</span><span class="attribute">border</span><span class="value">:<span class="number">1px</span> solid blue;</span><span class="attribute">position</span><span class="value">:relative;</span>}
<span class="comment">/*helpdiv相对于fahter向右移动father宽度的50%；*/</span>
<span class="class">.helpdiv</span>{<span class="attribute">position</span><span class="value">:absolute;</span><span class="attribute">left</span><span class="value">:<span class="number">50%</span>;</span><span class="attribute">border</span><span class="value">:<span class="number">1px</span> solid red;</span>}
<span class="comment">/*cur相对于cur自身，向左侧移动helpdiv的50%；因此最好不要设置helpdiv的宽度*/</span>
<span class="class">.cur</span>{<span class="attribute">position</span><span class="value">:relative;</span><span class="attribute">left</span><span class="value">:-<span class="number">50%</span>;</span>}
<span class="tag">HTML</span><span class="value">:
&lt;div class=<span class="string">"father"</span>&gt;
    &lt;div class=<span class="string">"helpdiv"</span>&gt;
           &lt;div class=<span class="string">"cur"</span>&gt;<span class="number">123456</span>&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;   </span>
</code></pre><p>  <div class="father" style="width:200px;height:200px;border:1px solid blue;position:relative;"></div></p>
<pre><code>    &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"helpdiv"</span> style=<span class="string">"position:absolute;left:50%;border:1px solid red;"</span>&gt;
           &lt;<span class="keyword">div</span> <span class="type">class</span>=<span class="string">"cur"</span> style=<span class="string">"position:relative;left:-50%;"</span>&gt;<span class="number">123456</span>&lt;/<span class="keyword">div</span>&gt;
    &lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;
</code></pre><h3 id="竖直居中：">竖直居中：</h3></li>
</ul>
</li>
<li><p>父元素高度不确定的文本、图片、块级元素的竖直居中：<br>给父元素设置相同的上下内边距(<strong>父高度确定时如此设置将不能实现竖直居中</strong>)      </p>
<pre><code>&lt;<span class="keyword">div</span> style=<span class="string">"border:1px solid blue;width:200px;padding:10px 20px;"</span>&gt;
    &lt;<span class="keyword">div</span> style=<span class="string">"height:50px;background-color:red;"</span>&gt;&lt;/<span class="keyword">div</span>&gt;
&lt;/<span class="keyword">div</span>&gt;  
</code></pre>  <div style="border:1px solid blue;width:200px;padding:10px 20px;"><br>  <div style="height:50px;background-color:red;"></div></div>  
</li>
<li><p>父元素高度确定的单行文本的竖直居中：<br>给父元素设置<code>line-height</code>值与<code>height</code>值相同      </p>
<pre><code><span class="tag">&lt;<span class="title">div</span> <span class="attribute">style</span>=<span class="value">"border:1px solid blue;width:200px;height:100px;line-height:100px;"</span>&gt;</span>
    <span class="tag">&lt;<span class="title">span</span> <span class="attribute">style</span>=<span class="value">"background-color:red;"</span>&gt;</span>单行文本<span class="tag">&lt;/<span class="title">span</span>&gt;</span>
<span class="tag">&lt;/<span class="title">div</span>&gt;</span>  
</code></pre>  <div style="border:1px solid blue;width:200px;height:100px;line-height:100px;"><br>  <span style="background-color:red;">单行文本</span></div>  </li>
<li><p>父高度确定的多行文本、图片、块级元素的竖直居中：  </p>
<ul>
<li>借助于table布局，将内容包含在td（th）中，在对td（th）设置<code>vertical-align:middle;</code>，这是由于<code>vertical-align</code>只对td、th才生效。  </li>
<li><p>hack：在IE8+以及非IE浏览器下，可以对父设置<code>display:table-cell</code>将其<code>vertical-align</code>激活，从而通过设置<code>vertical-align:middle</code>使子元素竖直居中。但在IE6、7下无效，在IE6、7下设置<code>postion、top</code>进行浮动抵消实现竖直居中。  </p>
<pre><code>CSS<span class="value">:
.wrap{background-color:Black;</span> 
      <span class="attribute">width</span><span class="value">:<span class="number">500px</span>;</span>
      <span class="attribute">color</span><span class="value">:<span class="hexcolor">#fff</span>;</span>
      <span class="attribute">height</span><span class="value">:<span class="number">100px</span>;</span>
      <span class="attribute">display</span><span class="value">:table-cell;</span>
      <span class="attribute">vertical-align</span><span class="value">:middle;</span>
      *<span class="attribute">position</span><span class="value">:relative;</span>
      }
 <span class="class">.verticalWrap</span>
 {
     <span class="attribute">border</span><span class="value">:<span class="number">1px</span> solid red;</span>
     *<span class="attribute">position</span><span class="value">:absolute;</span>
     *<span class="attribute">top</span><span class="value">:<span class="number">50%</span>;</span>
     }
  <span class="class">.vertical</span>

  {
      *<span class="attribute">position</span><span class="value">:relative;</span>
      *<span class="attribute">top</span><span class="value">:-<span class="number">50%</span>;</span>              
      }  
<span class="tag">HTML</span><span class="value">:  
&lt;div class=<span class="string">"father"</span>&gt;
    &lt;div class=<span class="string">"helpdiv"</span>&gt;
           &lt;div class=<span class="string">"cur"</span>&gt;<span class="number">123</span>&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;</span>
</code></pre></li>
</ul>
</li>
</ul>

          
        
      </div>
    

    
      <div class="post-footer">
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  

          </div>

          
            <div class="pagination">
              <a class="extend prev" rel="prev" href="/page/2/">&laquo;</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
            </div>
          
        </div>

        
<div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>

<div id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    

    <div class="site-overview">
      <div class="site-author motion-element">
        <img class="site-author-image" src="/images/default_avatar.jpg" alt="John Doe" />
        <p class="site-author-name">John Doe</p>
      </div>
      <p class="site-description motion-element"></p>
      <div class="site-state motion-element">
        <div class="site-state-item site-state-posts">
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">日志</span>
        </div>
        <div class="site-state-item site-state-tags">
            <span class="site-state-item-count">0</span>
            <span class="site-state-item-name">标签</span>
        </div>
        <div class="site-state-item site-state-pages">
            <span class="site-state-item-count">1</span>
            <span class="site-state-item-name">页面</span>
        </div>
      </div>

      

      <div class="social-info motion-element">
        
      </div>

      
      

    </div>

    

  </div>
</div>


      </div>
    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp; 
  2015
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">John Doe</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT</a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      $(".fancybox").fancybox();
    });
  </script>

  <script type="text/javascript">
  function hasMobileUA () {
    var nav = window.navigator;
    var ua = nav.userAgent;
    var pa = /iPad|iPhone|Android|Opera Mini|BlackBerry|webOS|UCWEB|Blazer|PSP|IEMobile|Symbian/g;

    return pa.test(ua);
  }

  function isDesktop () {
    return screen.width > 991 && !hasMobileUA();
  }

  function isTablet () {
    return screen.width < 992 && screen.width > 767 && hasMobileUA();
  }

  function isMobile () {
    return screen.width < 767 && hasMobileUA();
  }

  function escapeSelector (selector) {
    return selector.replace(/[!"$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&")
  }
</script>

  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  
  <script type="text/javascript" id="motion.page.home">
    $(document).ready(function () {
      $.Velocity.RunSequence([
        { e: $('.brand'), p: { opacity: 1 }, o: { duration: 100 } },
        { e: $('.logo'), p: { opacity: 1, top: 0 }, o: { duration: 50} },
        { e: $('.site-title'), p: { opacity: 1, top: 0 }, o: { duration: 200, sequenceQueue: false } }
      ]);
      $('.menu-item').velocity('transition.slideDownIn', {display: null});
    });
  </script>


  <script type="text/javascript" id="motion.global">
  $(document).ready(function () {
    var body = $('body');
    var isSidebarVisible = false;
    var sidebarToggle = $('.sidebar-toggle');
    var sidebarToggleLine1st = $('.sidebar-toggle-line-first')
    var sidebarToggleLine2nd = $('.sidebar-toggle-line-middle');
    var sidebarToggleLine3rd = $('.sidebar-toggle-line-last');
    var sidebar = $('.sidebar');

    var SIDEBAR_WIDTH = '320px';
    var SIDEBAR_DISPLAY_DURATION = 300;

    var sidebarToogleLineStatusInit = {width: '100%', opacity: 1, left: 0, rotateZ: 0, top: 0};

    var sidebarToggleLine1stStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine1stStatusArrow = {width: '50%', rotateZ: '-45deg', top: '2px'};
    var sidebarToogleLine1stStatusClose = {width: '100%', rotateZ: '-45deg', top: '5px'};

    var sidebarToggleLine2ndStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine2ndStatusArrow = {width: '90%'};
    var sidebarToogleLine2ndStatusClose = {opacity: 0};

    var sidebarToggleLine3rdStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine3rdStatusArrow = {width: '50%', rotateZ: '45deg', top: '-2px'};
    var sidebarToogleLine3rdStatusClose = {width: '100%', rotateZ: '45deg', top: '-5px'};

    sidebatToggleMotion();
    postsListMotion();
    backToTopMotion();


    $(document)
      .on('sidebar.isShowing', function () {
        isDesktop() && body.velocity(
          {paddingRight: SIDEBAR_WIDTH},
          SIDEBAR_DISPLAY_DURATION
        );
        sidebarContentMotion();
      })
      .on('sidebar.isHiding', function () {});


    function backToTopMotion () {
      var b2top = $('.back-to-top');
      b2top.on('click', function () {
        body.velocity('scroll');
      });
    }

    function sidebarShowMotion () {

      sidebarToggleLine1st.velocity(sidebarToogleLine1stStatusClose);
      sidebarToggleLine2nd.velocity(sidebarToogleLine2ndStatusClose);
      sidebarToggleLine3rd.velocity(sidebarToogleLine3rdStatusClose);

      sidebar.velocity({width: SIDEBAR_WIDTH}, {
        display: 'block',
        duration: SIDEBAR_DISPLAY_DURATION,
        complete: function () {
          sidebar.addClass('sidebar-active');
          sidebar.trigger('sidebar.didShow');
        }
      });
      sidebar.trigger('sidebar.isShowing');
    }

    function sidebarHideMotion () {
      isDesktop() && body.velocity({paddingRight: 0});
      sidebar.velocity('reverse');

      sidebarToggleLine1st.velocity(sidebarToggleLine1stStatusInit);
      sidebarToggleLine2nd.velocity(sidebarToggleLine2ndStatusInit);
      sidebarToggleLine3rd.velocity(sidebarToggleLine3rdStatusInit);

      sidebar.removeClass('sidebar-active');
      sidebar.trigger('sidebar.isHiding');
    };

    function sidebarContentMotion () {
      $('.sidebar .motion-element').velocity(
        'transition.slideRightIn',
        {stagger: 50, drag: true}
      );
    }

    function postsListMotion () {
      var postMotionOptions = postMotionOptions || {stagger: 300, drag: true};
      $('.post').velocity('transition.slideDownIn', postMotionOptions);
    }

    function sidebatToggleMotion () {
      sidebarToggle.on('click', function () {
        isSidebarVisible ? sidebarHideMotion() : sidebarShowMotion();
        isSidebarVisible = !isSidebarVisible;
      });

      sidebarToggle.hover(function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusArrow);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusArrow);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusArrow);
      }, function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusInit);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusInit);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusInit);
      });
    }
  });

</script>





  

  

  
  

  


  
</body>
</html>
