<!doctype html>
<html class="theme-next use-motion">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>




  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>


<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.3.0"/>





    <meta name="keywords" content="Hexo,next" />





    <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.3.0" />




  <title> 一只辰qie </title>
</head>

<body>
  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <div id="header" class="header">
      <div class="header-inner">
        <h1 class="site-meta">
    <a href="/" class="brand">
        <span class="logo">
          <i class="icon-logo"></i>
        </span>
        <span class="site-title">一只辰qie</span>
    </a>
</h1>


  <ul id="menu" class="menu">
    
      
      <li class="menu-item menu-item-home">
        <a href="/">
          <i class="menu-item-icon icon-home"></i> <br />
          首页
        </a>
      </li>
    
      
      <li class="menu-item menu-item-archives">
        <a href="/archives">
          <i class="menu-item-icon icon-archives"></i> <br />
          归档
        </a>
      </li>
    
      
      <li class="menu-item menu-item-tags">
        <a href="/tags">
          <i class="menu-item-icon icon-tags"></i> <br />
          标签
        </a>
      </li>
    
  </ul>


      </div>
    </div>

    <div id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content">
          
            
          

          <div id="posts" class="posts-expand">
            
  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/09/11/2014-09-11-colums/">
                使高度不定的列等高
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2014-09-11
          
        </span>
        
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <h2 id="想要达到的效果">想要达到的效果</h2><p>注意：难点在于这些列高度是可变的，不固定的。<br><img src="../images/equal_height6.PNG" alt="参数为DOM对象时jQuery对象内部结构"><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"wrapper"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"box"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">h1</span>&gt;</span>《赤裸裸》<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">p</span>&gt;</span></span><br><span class="line">           郑钧这张专辑主要面对的听众层是从18岁到30岁之间，其中包括高中生、大学生、以及走出校门步入社会时间不久的年轻人，正是这一代人中十分典型的心态。郑钧把他这份真实的感受，大胆质朴地流露在他的音乐中，相信会在年轻人中间产生强烈的共鸣。</span><br><span class="line">       <span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"box"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">h1</span>&gt;</span>郑钧简历<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">p</span>&gt;</span></span><br><span class="line">           1987年就读于杭州电子工业学院工业外贸专业，期间由于专业的影响接触了大量欧美摇滚乐，并开始最初的音乐创作。在校期间自己组建了一支乐队"火药"，并曾于杭州各高校间巡演受到热列欢迎。 </span><br><span class="line">           1992年开始了他的职业歌手生涯, 签约香港红星唱片公司。 </span><br><span class="line">           1994年6月发行首张个人专辑《赤裸裸》，十首歌曲全部由郑钧独自作词作曲并演唱。 专辑正版发行量超过五十万张，而据有据可查的盗版数量至少在一百五十万，是当年个人专辑发行量最高的歌手。其中《回到拉萨》、《赤裸裸》、《极乐世界》、《灰姑娘》、等作品今在国内广为流传。《回到拉萨》一曲曾创下了连续七周冠军、二十二周不下榜的记录，成为九四年中国乐坛的经典曲目。 </span><br><span class="line">           2000年10月 应邀参加TOSHIBA EMI “MUSIC TALKS” 现场表演轰动日本媒体和唱片界，成为全场焦点。 </span><br><span class="line">           2001年春 签约久负盛名的EMI唱片公司，成为百代中国首位内地巨星。 </span><br><span class="line">           2001年12月 加盟EMI后第一张个人专辑《郑钧》正式发行。 </span><br><span class="line">           2003年12月 《我们的生活》——充满阳光 <span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">     </span><br><span class="line">   <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"box"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">h1</span>&gt;</span>主要奖项<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">p</span>&gt;</span>1994年 《赤裸裸》获得了：94年中南十大金曲；94年广州十大金曲等数 十个奖项，他本人亦荣获北京"辉煌94"风云人物奖 </span><br><span class="line">           1996年 《赤裸裸》的ＭＴＶ保加利亚音乐节获音乐电视金奖；上海东方 电视台最佳MTV奖，本曲还曾获得过上海东方电视台的"群星耀东方"十大金曲、上海电台"茂盛杯"金曲奖，和96中国流行乐坛十年回顾"十年成就"奖。 </span><br><span class="line">           2002年6月 专辑《郑钧》荣获首届由中国音像协会主办的“中国唱片金碟奖”两大主力奖项：“最佳流行专辑奖”和“最佳摇滚专辑奖”。 </span><br><span class="line">     	<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h2 id="分步实现过程">分步实现过程</h2><h3 id="浮动形成3列">浮动形成3列</h3><p>在实现过程中，我会给元素添加边框，这样便于理解，完成后会将边框去掉<br>添加内边距和外边距，优化视觉效果<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.wrapper</span><br><span class="line">   &#123;</span><br><span class="line">     width:<span class="number">100</span>%;</span><br><span class="line">     border:<span class="number">1</span>px solid red;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">.box</span><br><span class="line">   &#123;</span><br><span class="line">       width:<span class="number">300</span>px;</span><br><span class="line">       float:left;</span><br><span class="line">       padding:<span class="number">20</span>px;</span><br><span class="line">       margin-left:<span class="number">20</span>px;</span><br><span class="line">       border:<span class="number">1</span>px solid #ccc;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/equal_height1.PNG" alt="参数为DOM对象时jQuery对象内部结构"></p>
<h3 id="清除浮动使父容器被撑开">清除浮动使父容器被撑开</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">	.wrapper:after</span><br><span class="line">    &#123;</span><br><span class="line">       content:<span class="string">"."</span>;</span><br><span class="line">       display:block;</span><br><span class="line">       clear:both;</span><br><span class="line">       height:<span class="number">0</span>;</span><br><span class="line">       visibility:hidden;</span><br><span class="line">        &#125;  </span><br><span class="line">```  </span><br><span class="line">![参数为DOM对象时jQuery对象内部结构](<span class="regexp">/images/</span>equal_height3.PNG)   </span><br><span class="line">### 关键步骤：使外边距和内边距抵消  </span><br><span class="line">给每个列添加大的底部内边距，将父容器撑大到一个很大的高度，    </span><br><span class="line">```javascript </span><br><span class="line">	.box</span><br><span class="line">    &#123;</span><br><span class="line">        width:<span class="number">300</span>px;</span><br><span class="line">        float:left;</span><br><span class="line">        padding:<span class="number">20</span>px;</span><br><span class="line">        margin-left:<span class="number">20</span>px;</span><br><span class="line">        border:<span class="number">1</span>px solid #ccc;</span><br><span class="line">        padding-bottom:<span class="number">300</span>px;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><img src="images/equal_height2.PNG" alt="参数为DOM对象时jQuery对象内部结构"><br>然后再使用数值相近的负外边距，这样使每个列有一部分溢出<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.box</span><br><span class="line">   &#123;</span><br><span class="line">       width:<span class="number">300</span>px;</span><br><span class="line">       float:left;</span><br><span class="line">       padding:<span class="number">20</span>px;</span><br><span class="line">       margin-left:<span class="number">20</span>px;</span><br><span class="line">       border:<span class="number">1</span>px solid #ccc;</span><br><span class="line">       padding-bottom:<span class="number">300</span>px;</span><br><span class="line">       margin-bottom:-<span class="number">280</span>px;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="/images/equal_height4.PNG" alt="参数为DOM对象时jQuery对象内部结构"> </p>
<h3 id="截断">截断</h3><p>再对父容器设置<code>overflow:auto</code>就将参差不齐的溢出部分截断，使它们高度相同<br>注意上面我设置的内边距为300，外边距为-280，这是为了使截断后，每个列还有20的内边距，视觉效果比较好。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.wrapper</span><br><span class="line">  &#123;</span><br><span class="line">    width:<span class="number">100</span>%;</span><br><span class="line">    border:<span class="number">1</span>px solid red;</span><br><span class="line">    overflow:auto;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="../images/equal_height5.PNG" alt="参数为DOM对象时jQuery对象内部结构"> </p>
<h3 id="设置颜色去除边框">设置颜色去除边框</h3><p><img src="../images/equal_height6.PNG" alt="参数为DOM对象时jQuery对象内部结构"> </p>
<h3 id="说明">说明</h3><p>在清除浮动时我使用了伪类，其实<code>overflow:auto</code>也能够清除浮动撑开父元素，但是在这个例子中我使用伪类就是想说明此时<code>overflow:auto</code>的最主要任务是截断。  </p>

          
        
      </div>
    

    
      <div class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/CSS/">
                #CSS
              </a>
            
          </div>
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/09/01/2014-09-01-scope-chain/">
                js中预编译与作用域链
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2014-09-01
          
        </span>
        
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <h2 id="写在前面">写在前面</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> val=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">	alert(val);<span class="comment">//undefined</span></span><br><span class="line">	<span class="keyword">var</span> val=<span class="number">10</span>;</span><br><span class="line">	alert(val);<span class="comment">//10</span></span><br><span class="line">&#125;</span><br><span class="line">alert(val)<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>原以为自己对于js的词法作用域理解的还不错，直到遇到一大波类似于上述的奇奇怪怪的现象后，我就有些凌乱了，成果如下：  </p>
<h2 id="作用域">作用域</h2><h3 id="变量作用域">变量作用域</h3><p>变量作用域scope可以理解为能够访问到这个变量的所有区域，例如可以在全局范围内访问到全局变量，那么全局变量的scope就是全局作用域。  </p>
<h3 id="函数作用域">函数作用域</h3><p>对于函数来讲，任何在函数内部定义的变量、函数的参数、在函数内定义的其他函数都是<strong>局部变量</strong>。只有在函数的内部才能访问到这些局部变量。<br><strong>函数作用域</strong>：函数的内部变量其scope是这个函数体以及这个函数体内嵌套的任意函数体内部。<br><strong>声明提前：</strong>由函数作用域知内部变量在函数体内任何位置都是可访问的，这就导致有可能变量在声明前就是可访问的。在js中函数内声明的所有变量其声明过程都被<strong>提前</strong>到函数体的顶部，而赋值过程仍在代码中原位置。这时由JS引擎的“预编译”导致的。<br><strong>内部变量的优先级：</strong>同名的内部变量的优先级要高于全局变量，这也可由作用域链可知。  </p>
<h3 id="js的词法作用域链">js的词法作用域链</h3><p>当函数在<strong>定义</strong>时，就保存了一个<strong>作用域链</strong>。作用域链确保了可访问的变量和函数，以及访问顺序。作用域链式在代码<strong>定义时</strong>就已确定的，而不是等到执行时才确定。    </p>
<h3 id="变量解析">变量解析</h3><p>沿着作用域链前端的第一个对象开始查找，一旦找到就返回。    </p>
<h2 id="预编译">预编译</h2><h3 id="对预编译的理解">对预编译的理解</h3><p>js在执行前会对代码进行<strong>预编译</strong>，关于预编译需要注意几点：     </p>
<ul>
<li><strong>预编译</strong>工作范围：对var变量声明、以及<code>function(){}</code>函数体内的代码进行处理，并不进行赋值操作。赋值操作发生在执行阶段。举例说明三种情况：    <ul>
<li><code>var val=1;</code>预编译只做了声明的工作即<code>var val;</code>  </li>
<li><code>function f(){/函数体代码段}</code>遇到这样的函数定义，会对函数体内代码段进行预编译  </li>
<li><code>var f=function(){//函数体代码段}</code>这种情况严格意义上讲不属于函数定义，称为对变量f进行声明和初始化比较合适，因此预编译只进行变量f的声明即<code>var f;</code>，对匿名函数体内代码段不进行预编译。  </li>
</ul>
</li>
</ul>
<ul>
<li><p>js的代码是<strong>顺序分块</strong>进行<strong>预编译-执行</strong> 的过程的。顺序是指按照代码定义顺序从上到下进行，分块是针对有多个<code>&lt;script type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</code>块时，按顺序将第一个<code>&lt;script&gt;&lt;/script&gt;</code>块内代码预编译然后执行，再对下一个<code>&lt;script&gt;&lt;/script&gt;</code>重复该<strong>预编译-执行</strong>的过程。    </p>
</li>
<li><p>由上条可知，当有多个代码块时，后面出现的<code>&lt;script&gt;&lt;/script&gt;</code>代码块能够访问前面出现的<code>&lt;script&gt;&lt;/script&gt;</code>代码块内的全局变量，反过来则不行。    </p>
</li>
<li><p>对函数内部代码进行预编译时，会忽略逻辑判断。例如<code>if(false){var val=1;}</code>仍然会进行<code>var val;</code>预编译。</p>
</li>
</ul>
<h3 id="对预编译、执行、作用域链之间关系的理解">对预编译、执行、作用域链之间关系的理解</h3><p>其实对《Javascript权威指南》和《javascript高级程序设计》里面关于这些的讲解总觉得特别抽象，看完也觉得不知道内部实现机制。自己的理解不知道是否完全正确，但是总能解释下面奇怪的例子们~<br><strong>板板的理解：</strong>在定义函数时就为其保存了一个作用域链，预编译完成后对该作用域链进行修改，在代码的执行过程中也会对其进行修改。看示例一：  </p>
<h4 id="示例一：">示例一：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="function"><span class="keyword">function</span> <span class="title">a</span><span class="params">(o)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">var</span> x = <span class="number">4</span>;</span><br><span class="line">       alert(i);</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">typeof</span> o == <span class="string">"object"</span>) &#123;</span><br><span class="line">           <span class="keyword">var</span> i = <span class="number">2</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">function</span> <span class="title">b</span><span class="params">(r)</span> </span>&#123;</span><br><span class="line">               y = <span class="number">5</span>;</span><br><span class="line">           alert(i);</span><br><span class="line">       &#125;;</span><br><span class="line">       b(<span class="number">40</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   a(<span class="number">10</span>);<span class="comment">//undefined、undefined</span></span><br><span class="line">a(&#123;&#125;);<span class="comment">//undefined、2</span></span><br></pre></td></tr></table></figure>
<p>上述代码在预编译完成后期作用域链如下图所示：<br><img src="/images/scope_chain1.PNG" alt="参数为DOM对象时jQuery对象内部结构"><br>由上图可以看出，在预编译完成后，代码执行前，各变量已经是可访问的，只是未赋值。<br>在代码执行过程中，会动态改变作用域链，例如，我们可以画出调用<code>a(10)</code>代码执行到第一个<code>alert(i)</code>时的作用域链：<br>  <img src="/images/scope_chain2.PNG" alt="参数为DOM对象时jQuery对象内部结构"><br>由上图可知：<br>b()的作用域链为：b()的变量对象-》a()的变量对我-》window全局变量对象<br>a()的作用域链为：a()的变量对象-》window全局变量对象<br>window的作用域链为：window全局变量对象<br><strong>在变量解析过程中，</strong>只能<strong>从下到上</strong>在其作用域链上进行搜索。  </p>
<p><code>a(10);</code>调用过程：遇到第一个<code>alert(i)</code>，在a()变量对象中搜索i，搜索到了，其值为undefined，由于未满足if条件，故没能进行赋值操作，i值不变；遇到第二个<code>alert(i)</code>时，在b()变量对象中未搜索i，就沿着作用域链向上搜索到a()变量对象，搜索到i，此时其值为undefined。<br><code>a({})</code>调用过程：遇到第一个<code>alert(i)</code>，在a()变量对象中搜索到i即刻停止搜索，其值为undefined，进行if判断满足，对i进行赋值2；调用b，进行到第二个<code>alert(i)</code>时，在b()变量对象中未搜多到i，沿着作用域链向上搜索到a()变量对象，找到i，其值为2.  </p>
<h4 id="示例二：来说明在预编译时对函数的两种定义的区别对待">示例二：来说明在预编译时对函数的两种定义的区别对待</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">	test1(); <span class="comment">//undefined</span></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">		alert(<span class="keyword">typeof</span> test2);</span><br><span class="line">    &#125;</span><br><span class="line">    test1();<span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> test2 = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        alert(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  	test1(); <span class="comment">//3    </span></span><br><span class="line">``` </span><br><span class="line">从上面代码可看出，函数test2是以变量赋值的方法进行定义的，这样预编译时仅进行`<span class="keyword">var</span> test2;`而不管其代码段，test2的值为<span class="literal">undefined</span>。这样在第一次和第二次test1()时可以访问test2，但其值为<span class="literal">undefined</span>，这时候执行test2会报错。而按照test1()方式定义的函数在其所在环境内任何地方都是可以执行的。    </span><br><span class="line"></span><br><span class="line">#### 示例三：  </span><br><span class="line">```javascript</span><br><span class="line">	<span class="keyword">var</span> val=<span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		alert(val)</span><br><span class="line">		val=<span class="number">10</span>;</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">val</span><span class="params">()</span></span>&#123;</span><br><span class="line">		&#125;</span><br><span class="line">		alert(val);</span><br><span class="line">		alert(<span class="keyword">typeof</span> val);</span><br><span class="line">	&#125;  </span><br><span class="line">	test();<span class="comment">//一次弹出undefined、10、number/function</span></span><br><span class="line">	alert(val);<span class="comment">//1</span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">#### 示例四：重复声明变量不会影响原来的值  </span><br><span class="line">```javascript  </span><br><span class="line">	<span class="keyword">var</span> i=<span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">var</span> i;</span><br><span class="line">		alert(i);</span><br><span class="line">    &#125;</span><br><span class="line">    test1();  <span class="comment">//10</span></span><br><span class="line">	alert(i);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>由上述代码可以发现，重复声明不会影响变量原来的值。个人理解原因如下：在预编译过程中，进行了两次<code>var i;</code>，就可以说为test1()的变量对象添加了两次i属性，由于同名属性会进行覆盖，因此最终test1()的变量对象只有一个i属性(我认为两个i指向同一个内存块)。那再进行执行的时候，<code>var i=10;</code>为test1()的变量对象的i属性赋值为10，<code>var i;</code>没有赋值，因此最终test1()变量对象的i属性值就为10.作用域链如下图：<br><img src="/images/scope_chain3.PNG" alt="参数为DOM对象时jQuery对象内部结构"></p>
<h4 id="示例四：证实预编译-执行过程是按&lt;script&gt;&lt;/script&gt;块进行的">示例四：证实<strong>预编译-执行</strong>过程是按<code>&lt;script&gt;&lt;/script&gt;</code>块进行的</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">	test()<span class="comment">//出错  </span></span><br><span class="line">	<span class="keyword">var</span> i=<span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">		i=<span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	f();</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="title">script</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	alert(i)<span class="comment">//2</span></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>由以上代码可知，在第一个<code>&lt;sctipt&gt;</code>块调用第二个代码块中函数会出错，这是由于第二个<code>&lt;script&gt;</code>还未进行预编译，是不可访问到的。第二个代码块可以访问到第一个代码块的全局变量，是因为此时第一个代码块已经预编译切执行结束了.</p>
<h4 id="示例五:预编译时会忽略逻辑判断">示例五:预编译时会忽略逻辑判断</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">var</span> foo=<span class="number">1</span>;</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!foo)&#123;</span><br><span class="line">			<span class="keyword">var</span> foo=<span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		alert(foo);</span><br><span class="line">	&#125;  </span><br><span class="line">	test()<span class="comment">//2  </span></span><br><span class="line">``` </span><br><span class="line">在预编译结束后,上述代码中test()的变量对象的foo属性为<span class="literal">undefined</span>，因此，执行时<span class="keyword">if</span>(!foo)判断为真。这样就好像在执行时foo的声明提前了。</span><br><span class="line">     </span><br><span class="line">#### 实例六   </span><br><span class="line">```javascript  </span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(val)</span></span>&#123;</span><br><span class="line">		<span class="keyword">var</span> val=<span class="number">10</span>;</span><br><span class="line">		alert(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">	f(<span class="number">1</span>)<span class="comment">//10</span></span><br></pre></td></tr></table></figure>
<p>由实例四可知参数val和内部重复定义的val在预编译时指向同一块内存，进行两次赋值后其值为10；还要注意函数的arguments值永远和对应命名参数的值保持一致，任何一方改变都会体现在另一方，但是要知道它们内存空间是独立的。  </p>

          
        
      </div>
    

    
      <div class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/JS/">
                #JS
              </a>
            
          </div>
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/08/30/2014-08-31-object1/">
                js对象之一（原型及原型链）
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2014-08-30
          
        </span>
        
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <h2 id="写在前面">写在前面</h2><p>下决心整理对象相关，是因为看到下面这个现象：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>);<span class="comment">//true  </span></span><br><span class="line">alert(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>虽然知道结果都是<code>true</code>,但是解释原因时觉得一句”一切对象都继承自<code>Oject</code>“显得太过苍白。</p>
<h2 id="原型及原型链">原型及原型链</h2><p><strong>构造函数就是函数！</strong>任何函数通过new操作符调用，那它就是构造函数；任何函数，不通过new来调用，那就和普通的函数没有任何区别。    </p>
<p>任何时候，只要！创建一个函数，就为该函数创建一个属性prototype，指向一个原型对象，<strong>原型对象实质上是对象</strong>，因此是原型对象是Object的实例。而任何函数都是Function的实例。  </p>
<p><strong>构造函数、原型、实例之间的关系图如下所示：</strong><br><img src="../images/prototype1.PNG" alt="参数为DOM对象时jQuery对象内部结构"> </p>
<p><strong>Function、Array、Object</strong>这些构造函数其实质都是 <strong>函数！</strong>那就可以理解为它们是Function的实例;<br><strong>Function.prototype、Array.prototype</strong>这些原型对象归根结底都是对象，因此它们都是Object的实例。<br>由此可以得出下图：  </p>
<p> <img src="../images/prototype2.PNG" alt="参数为DOM对象时jQuery对象内部结构"><br>由上图可以看出（原型链是跟着[[prototype]]走的）：    </p>
<ul>
<li>Function的原型链为：    Function———》Function.prototype ————》Object.prototype    </li>
<li>Object的原型链为：  Object——》Function.prototype ——》Object.prototype  </li>
<li>F的原型链为：F ——》Function.prototype ——》Object.prototype    </li>
<li>f1的原型链为：f1 ——》F.prototype ——》Object.prototype</li>
</ul>
<p>由上可以看出，<strong>任何对象的原型链其根节点都是Object.prototype，这也是为什么说js中任何对象都是继承自Object</strong>。  </p>
<p><strong>操作符instanceof的含义：</strong><br><code>O instanceof F</code> O是对象，F是函数。若O为F的一个实例则返回true，反之返回false。其工作原理为：若在O的原型链中能找到F则返回true。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> f1=<span class="keyword">new</span> F();    </span><br><span class="line">alert(F <span class="keyword">instanceof</span> <span class="built_in">Function</span>)<span class="comment">//true  </span></span><br><span class="line">alert(f1 <span class="keyword">instanceof</span> <span class="built_in">Function</span>)<span class="comment">//false  </span></span><br><span class="line">alert(f1 <span class="keyword">instanceof</span> F)<span class="comment">//true</span></span><br><span class="line">alert(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>)<span class="comment">//true  </span></span><br><span class="line">alert(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>)<span class="comment">//true    </span></span><br><span class="line">alert(<span class="built_in">Object</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span>)<span class="comment">//true  </span></span><br><span class="line">alert(<span class="built_in">Function</span> <span class="keyword">instanceof</span> <span class="built_in">Function</span>)<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p><strong>方法isPrototypeOf()的含义：</strong><br><code>O1.isPrototypeOf(O2)</code>其中O1、O2都是对象。表面含义是若O1是O2的原型对象则返回true。实际上，若对象O2的[[prototype]]属性指向O1则返回true。工作原理为：若能在O2的原型链上找到O1则返回true。因此：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">var</span> f1=<span class="keyword">new</span> F();    </span><br><span class="line">alert(<span class="built_in">Object</span>.prototype.isPrototypeOf(<span class="built_in">Function</span>));<span class="comment">//true;</span></span><br><span class="line">alert(<span class="built_in">Function</span>.prototype.isPrototypeOf(<span class="built_in">Function</span>));<span class="comment">//true</span></span><br><span class="line">alert(<span class="built_in">Object</span>.prototype.isPrototypeOf(<span class="built_in">Object</span>));<span class="comment">//true </span></span><br><span class="line">alert(<span class="built_in">Function</span>.prototype.isPrototypeOf(<span class="built_in">Object</span>));<span class="comment">//true </span></span><br><span class="line">alert(<span class="built_in">Object</span>.prototype.isPrototypeOf(f1));<span class="comment">//true</span></span><br><span class="line">alert(F.prototype.isPrototypeOf(f1))<span class="comment">//true;</span></span><br></pre></td></tr></table></figure></p>
<p>最后，附上mollypages.org的一张图，与上图本质上是一样的：<br> <img src="/images/prototype3.PNG" alt="参数为DOM对象时jQuery对象内部结构">   </p>
<h2 id="对象中属性的读取">对象中属性的读取</h2><p>当读取对象的一个属性时，实际是进行了一次<strong>搜索</strong>。搜索先从实例本身开始，若找到则停止搜索返回其值；若未找到，则继续搜索其[[prototype]]指向的原型对象，若找到返回，未找到返回undefined。<br>这也就是为什么不管是先创建实例还是先修改原型，原型的修改都会立即体现在所有实例上。    </p>
<p>可以通过对象实例<strong>访问</strong>原型中的值；<br>当原型中的属性值为引用类型时，可以通过实例进行 <strong>修改</strong>，但这个修改会体现在所有实例上；<br>但是不能通过实例对原型中的值进行 <strong>重写</strong>。当实例中的属性名与原型中属性名相同时，实例中的属性名会 <strong>屏蔽</strong>原型中的该属性，因为 <strong>搜索</strong>提前结束了,也就是说这只会阻止访问原型中的那个值，但不会改变原型中的值。可通过 <strong>delete</strong>操作符删除实例属性，是原型属性重新可访问。看以下示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	F.prototype.arr=[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">var</span> f1=<span class="keyword">new</span> F();</span><br><span class="line">	<span class="keyword">var</span> f2=<span class="keyword">new</span> F();</span><br><span class="line">	<span class="comment">/********修改*********/</span></span><br><span class="line">	f1.arr.push(<span class="number">2</span>);</span><br><span class="line">	alert(f2.arr)<span class="comment">//[1,2]  </span></span><br><span class="line">  	<span class="comment">/*********重写************/</span></span><br><span class="line">	f1.arr=[<span class="number">2</span>];</span><br><span class="line">	alert(f2.arr)<span class="comment">//[1]  </span></span><br><span class="line">```  </span><br><span class="line">**hasOwnProperty()**  </span><br><span class="line">这是对象的一个方法，是从<span class="built_in">Object</span>继承而来的。`O.hasOwnProperty(attr)`判断属性attr是否为对象O的实例属性，是返回<span class="literal">true</span>。实质就是体现是在实例中搜索到的属性attr还是在原型中搜索到的属性attr。  </span><br><span class="line">  </span><br><span class="line">**<span class="keyword">in</span>操作符**    </span><br><span class="line"></span><br><span class="line">- 单独使用时`attr <span class="keyword">in</span> object1`，若能在对象object1中找到属性attr，则返回ture，而不管该属性是否可枚举，是在实例中还是原型中；  </span><br><span class="line">- 使用`<span class="keyword">for</span>-<span class="keyword">in</span>`返回能通过对象访问到的、可枚举的属性，而不管该属性在实例中还是原型中。按照规定，在实例中定义的属性都是可枚举的，包括那些屏蔽了原型中不可枚举的实例属性。但是在IE8及IE8-存在一个bug，即屏蔽了原型中不可枚举的实例属性不会在<span class="keyword">for</span>-<span class="keyword">in</span>中出现。</span><br><span class="line">  </span><br><span class="line">## 重写原型  </span><br><span class="line">**重写原型的后果：**  </span><br><span class="line"><span class="number">1.</span>切断了构造函数与最初原型的关系，构造函数的prototype属性原始指向最初原型，现在被重写指向新原型；  </span><br><span class="line">```javascript	  </span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    F.prototype = &#123; </span><br><span class="line">		constructor:F;</span><br><span class="line">		arr: [<span class="number">1</span>] &#125;;</span><br></pre></td></tr></table></figure></p>
<p>如下图所示：<br><img src="../images/prototype4.PNG" alt="参数为DOM对象时jQuery对象内部结构"><br>2.切断了重写原型前创建的所有实例与新原型的联系，之前的实例仍然指向初始原型。这是由于每次新建实例时，赋给该实例一个[[prototype]]属性，指向当时的原型。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">var</span> f1 = <span class="keyword">new</span> F();</span><br><span class="line">   F.prototype = &#123; arr: [<span class="number">1</span>] &#125;;</span><br><span class="line">   <span class="keyword">var</span> f2 = <span class="keyword">new</span> F();</span><br><span class="line">   alert(f2.arr);<span class="comment">//1</span></span><br><span class="line">   alert(f1.arr);  <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p>
<p>如下图所示：<br><img src="../images/prototype5.PNG" alt="参数为DOM对象时jQuery对象内部结构">    </p>

          
        
      </div>
    

    
      <div class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/JS/">
                #JS
              </a>
            
          </div>
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/08/14/viewport/">
                对viewport的部分理解
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2014-08-14
          
        </span>
        
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <h2 id="写在前面">写在前面</h2><p>最近第一次接触接触移动端的前端开发，发现水很深，要持续学习的还有很多。遇到了一些和<code>viewport</code>相关的问题，看了很多前辈的文章和总结终于有了一点点理解。</p>
<p>第一次接触<code>viewport</code>是要求页面为手机、平板、pc等不同设备做合理的适配。当时我只听说过媒体查询，以为有了媒体查询和百分比就能搞定响应式设计。当我写完媒体查询，在手机上打开页面时，发现页面已经被缩小到无法正常浏览了。后来我知道应该加上<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</code>，至于为什么我没有深究。  </p>
<p>第二次接触是在一个移动端页面的原代码里我看到了这样的逻辑处理：检测到设备是retina屏时元素的尺寸（宽、高、边框、图片大小等）均是非retina屏的2倍，且retina屏下页面初始缩放比例为0.5即<code>&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=0.5&gt;</code>，非retina屏下页面初始缩放比例为1即<code>&lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1&gt;</code>。我当时就觉得简直无法理解，为什么非要在retina屏下先是尺寸放大2倍然后再把页面缩小为0.5，直接都为1不行吗？当时去查了下devicePixelRatio相关，还是懵懵懂懂。  </p>
<p>以下均以iPhone5s（分辨率为640x1136）为例。  </p>
<h2 id="设置width=device-width时，发生了什么">设置<code>width=device-width</code>时，发生了什么</h2><p>首先来研究下我遇到的第一个问题：我原以为给页面宽度设置了100%它就能自适应手机屏宽度，而事实是在手机浏览器里它被缩放到无法直视。  </p>
<p>那么给页面宽度设置了100%，而不设置<code>width=device-width</code>时，发生了什么<br>先看下面代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.documentElement.clientWidth);<span class="comment">//980</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">document</span>.documentElement.scrollWidth);<span class="comment">//980</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.screen.width);<span class="comment">//320横屏</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.screen.width);<span class="comment">//568竖屏</span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">以上是页面宽度为<span class="number">100</span>%的页面在iPhone5s中Safari上的运行结果。由结果可知，此时无论横屏还是竖屏网页实际宽度是<span class="number">980</span>px，可以理解为实际上是把<span class="number">980</span>px宽的页面缩放在了<span class="number">320</span>宽的容器里，其文字效果自然被缩放到影响阅读。那这个<span class="number">980</span>px是哪来的呢？下面会说到。  </span><br><span class="line"></span><br><span class="line">现在我们给页面宽度设置<span class="number">100</span>%，并进行设置`&lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width"</span>&gt;`，此时页面效果（字体大小等）就舒服多了。看以下代码输出：</span><br></pre></td></tr></table></figure>
<p>console.log(document.documentElement.clientWidth);//竖屏下320，横屏下568<br>console.log(document.documentElement.scrollWidth);//竖屏下320，横屏下568<br>console.log(window.screen.width);//320<br>console.log(window.screen.height);//568<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">看到以上输出，我们先思考以下问题：  </span><br><span class="line"></span><br><span class="line">1. `width=device-width`中的width设置的是谁的宽度？   </span><br><span class="line">Apple在移动版的Safari中定义了`viewport meta`标签，该标签创建了一个虚拟的窗口`layout viewprot`，这里的width即是对虚拟窗口的值进行设置。在Apple在移动版的Safari中其默认值为980px。我们开发的页面就是在这个虚拟窗口里进行布局的。  </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">2. `width=device-width`中的device-width是谁的值，值是多少？  </span><br><span class="line">我感觉可以将device-width看做是‘设备独立像素’，在iphone竖屏下其值为320，单位都是物理像素。其实，可以将device-width跟window.screen.width/height(横/竖屏)对应起来。设置了之后`layout viewport`宽度就变为了320px（竖屏）、568px（横屏），单位都是CSS像素。</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">## 为什么1x图片在retina屏下会糊掉？   </span></span><br><span class="line"></span><br><span class="line">在研究这个问题之前，我们先看下retina、非retina之间的区别。显然的是retina屏比非retina屏要清晰，其原因通俗点说就是因为retina屏在相同尺寸的屏幕下拥有的物理像素多于非retina屏。我们看到的图像都是通过物理像素展现的，物理像素越密集图像就越清晰。这就引出了设备像素比devicePixelRatio：   </span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span>devicePixelRatio=设备物理像素/设备独立像素<span class="keyword">*</span><span class="keyword">*</span>    </span><br><span class="line">以iPhone为例，retina下devicePixelRatio=1，非retina下devicePixelRatio=2.  </span><br><span class="line">无论是retina还是非retina屏，竖屏下，设备独立像素都是320，而它们的设备物理像素分别为640、320。  </span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span>物理像素与CSS像素的关系：<span class="keyword">*</span><span class="keyword">*</span>  </span><br><span class="line">页面的清晰和模糊其实可以通过设备物理像素和css像素的关系来解释。在页面缩放比例为100%时：  </span><br><span class="line">非retina屏下，一个css像素“覆盖”在一个设备物理像素上；  </span><br><span class="line">retina屏下，一个css像素“覆盖”在四个设备物理像素上，实质是一个css像素被瓜分成了四份，效果就变糊了。  </span><br><span class="line">例如，同样一个10x10px的图片，在非retina屏下占据的物理像素是10x10；在retina屏下占据的物理像素是20x20，平均一个物理像素瓜分到四分之一的css像素，那么物理像素在表现图像时取颜色相似值，效果就糊了。</span><br><span class="line"></span><br><span class="line"><span class="keyword">*</span><span class="keyword">*</span>页面缩放时发生了什么？<span class="keyword">*</span><span class="keyword">*</span>  </span><br><span class="line">缩小网页时，发现screen.width不变，window.clientWidth变大，意思是同样的屏幕可以容纳的css像素更多了（可以理解为多个css像素挤在一起），放大网页正好相反。因此进行设置`<span class="variable">&lt;meta name="viewport" content="width=device-width,initial-scale=0.5"&gt;</span>`后：</span><br></pre></td></tr></table></figure></p>
<p>console.log(document.documentElement.clientWidth);//竖屏下640px<br>console.log(document.documentElement.scrollWidth);//竖屏下640px<br>console.log(window.screen.width);//320<br><code>``  
设置缩放比例</code>initial-scale=0.5`之后，window.clientWidth变为原来2倍，同样屏幕内的css像素数变为之前的4倍，此时在retina屏下一个css像素“覆盖”在一个设备物理像素上，效果就变清晰了。</p>
<p>做以下测试：  </p>
<ol>
<li>同一张图片，准备两个尺寸分别为320x320、640x640  </li>
<li>页面1包含320x320px的图片，且设置<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</code>  </li>
<li>页面2包含640x640px的图片，且设置<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=0.5&quot;&gt;</code>  </li>
<li>在retina屏iPhone下观察页面1和页面2的效果  </li>
</ol>
<p>可以看出两个页面图片（宽度）都刚好铺在屏幕上，不同的是页面2明显比页面1清晰。这正是由于在页面2中css像素与设备像素是1：1，而在页面1中css像素与设备像素是1：4.   </p>

          
        
      </div>
    

    
      <div class="post-footer">
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/08/14/node-debug/">
                Node调试方法
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2014-08-14
          
        </span>
        
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <h2 id="前言">前言</h2><p>本文主要介绍三种调试Node的方法：命令行调试、Node-Inspector、使用WebStrom进行调试。</p>
<p>待调试文件index.js，以下调试方法均是基于该文件：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="reserved">var</span> http=<span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="reserved">function</span>(req,res)&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>,&#123;<span class="string">'Content-Type'</span>:<span class="string">'text/html'</span>&#125;);</span><br><span class="line">    res.write(<span class="string">'&lt;h1&gt;Node.js&lt;/h1&gt;'</span>);</span><br><span class="line">    res.write(<span class="string">'&lt;p&gt;Hello World&lt;/p&gt;'</span>);</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"listening at port 3000"</span>);</span><br><span class="line">`<span class="javascript"></span>``<span class="javascript">    </span><br><span class="line">## 方式一：命令行调试Debugger  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Debugger是Node内置的调试工具。下面主要介绍使用Debugger的调试步骤以及各调试指令的含义。</span><br><span class="line"></span><br><span class="line">### <span class="number">1.</span> 在代码中加入断点  </span><br><span class="line">调试前，通过语句</span>`<span class="keyword">debugger</span>;`<span class="javascript">设置断点位置，修改index.js文件如下：</span></span><br></pre></td></tr></table></figure>
<p>var http=require(‘http’);</p>
<p>http.createServer(function(req,res){<br>    res.writeHead(200,{‘Content-Type’:’text/html’});<br>    debugger;    //第一个断点<br>    res.write(‘</p><h1>Node.js</h1>‘);<br>    debugger;    //第二个断点<br>    res.write(‘<p>Hello World</p>‘);<br>}).listen(3000);<br>console.log(“listening at port 3000”);<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">### 2.通过命令行进入调试模式  </span></span><br><span class="line">  </span><br><span class="line">在浏览器中访问要调试的页面，在命令行输入以下命令：</span><br></pre></td></tr></table></figure><p></p>
<p>$node debug index.js ￼<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">开启Node的调试功能，输出结果如下：  </span><br><span class="line"></span><br><span class="line">![<span class="link_label">11</span>](<span class="link_url">http://img2.tbcdn.cn/L1/461/1/d272b16eab9b82cf054625758ba883bf1cb639de</span>)  </span><br><span class="line">代码执行到<span class="code">`debugger;`</span>语句会暂停，提示输入指令。  </span><br><span class="line">输入指令进行调试，如下图：  </span><br><span class="line"></span><br><span class="line">![<span class="link_label">12</span>](<span class="link_url">http://img3.tbcdn.cn/L1/461/1/59dddaf134148970c59266ee13b8b7e70767365c</span>) </span><br><span class="line">  </span><br><span class="line"><span class="header">### 相关指令含义  </span></span><br><span class="line">以下部分来自[<span class="link_label">Debugger</span>](<span class="link_url">http://nodejs.org/api/debugger.html</span>)  </span><br><span class="line"><span class="header">#### 步进指令  </span></span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>cont或c —— 继续执行  </span><br><span class="line"><span class="bullet">* </span>next或n —— 执行到下一个断点  </span><br><span class="line"><span class="bullet">* </span>step或s —— 进入函数内部  </span><br><span class="line"><span class="bullet">* </span>out或o ——跳出函数  </span><br><span class="line"><span class="bullet">* </span>pause ——暂停执行 </span><br><span class="line"></span><br><span class="line"><span class="header">#### 断点操作  </span></span><br><span class="line">  </span><br><span class="line"><span class="bullet">* </span>setBreakpoint()或sb() —— 在当前行设置断点  </span><br><span class="line"><span class="bullet">* </span>setBreakpoint(line)或sb(line) —— 在特定行line设置断点  </span><br><span class="line"><span class="bullet">* </span>setBreakpoint('fn()'), sb(...) —— 在函数fn内部第一个声明出设置断点  </span><br><span class="line"><span class="bullet">* </span>setBreakpoint('script.js', 1), sb(...) —— 在文件script.js第一行设置断点  </span><br><span class="line"><span class="bullet">* </span>clearBreakpoint, cb(...) —— 删除断点  </span><br><span class="line"></span><br><span class="line"><span class="header">#### 信息查看  </span></span><br><span class="line">  </span><br><span class="line"><span class="bullet">* </span>backtrace或bt —— 输出当前执行下的堆栈信息  </span><br><span class="line"><span class="bullet">* </span>list(5) —— 输出当前上下各5行源代码  </span><br><span class="line"><span class="bullet">* </span>watch(expr) —— 添加表达式expr至观察列表  </span><br><span class="line"><span class="bullet">* </span>unwatch(expr) —— 从观察列表中移除表达式expr  </span><br><span class="line"><span class="bullet">* </span>watchers —— 列出观察列表中所有的表达式和他们的值  </span><br><span class="line"><span class="bullet">* </span>repl —— 调试脚本上下文中代码</span><br><span class="line"></span><br><span class="line"><span class="header">#### 执行控制  </span></span><br><span class="line">  </span><br><span class="line"><span class="bullet">* </span>run —— 启动脚本  </span><br><span class="line"><span class="bullet">* </span>restart —— 重启脚本  </span><br><span class="line"><span class="bullet">* </span>kill —— 终止脚本</span><br><span class="line"> </span><br><span class="line"><span class="header">#### 其他  </span></span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>scripts - 列出所有已加载的脚本  </span><br><span class="line"><span class="bullet">* </span>version - 显示 V8 的版本  </span><br><span class="line"></span><br><span class="line"><span class="header">## 方式二：Node-inspector    </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Node Inspector是基于方式一中的API实现的界面化的Node调试工具，不过node-inspector需要在Webkit内核下浏览器进行调试。以下是调试步骤：  </span><br><span class="line"></span><br><span class="line"><span class="header">### 1. 全局安装node-inspector</span></span><br></pre></td></tr></table></figure></p>
<p>$ npm install node-inspector -g<br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">### 2. 启动node-inspector监听Nodejs的debug调试端口</span></span><br></pre></td></tr></table></figure></p>
<p>$ node-inspector￼<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">命令行输出如下图：  </span><br><span class="line">![<span class="link_label">1</span>](<span class="link_url">http://img1.tbcdn.cn/L1/461/1/aebe35fb6682e75742dadb1ff2f1769de1352eb2</span>)</span><br><span class="line"></span><br><span class="line"><span class="header">### 3. 打开浏览器，输入上图中显示地址  </span></span><br><span class="line">[<span class="link_label">`http://127.0.0.1:8080/debug?port=5858`</span>](<span class="link_url">http://127.0.0.1:8080/debug?port=5858</span>),将看到如下调试窗口：  </span><br><span class="line"></span><br><span class="line">![<span class="link_label">2</span>](<span class="link_url">http://img1.tbcdn.cn/L1/461/1/2b81f0ea1f3532c968946532bf6a98192b5f2a80</span>)</span><br><span class="line"></span><br><span class="line"><span class="header">### 4. 将需要调试的代码文件载入到上述调试窗口。  </span></span><br><span class="line">再打开一个命令行，输入：</span><br></pre></td></tr></table></figure></p>
<p>$ node —debug index.js<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">此时刷新[<span class="link_label">`http://127.0.0.1:8080/debug?port=5858`</span>](<span class="link_url">http://127.0.0.1:8080/debug?port=5858</span>)会发现index.js已载入调试窗口，如下图所示：  </span><br><span class="line"></span><br><span class="line">![<span class="link_label">3</span>](<span class="link_url">http://img2.tbcdn.cn/L1/461/1/fedea101eda09581333cd02d1f2dcc2d5a052e6c</span>) </span><br><span class="line"></span><br><span class="line"><span class="header">### 5. 新打开一个浏览器页签，刷新你要调试的页面.  </span></span><br><span class="line">当执行到设置断点的位置时，页面会暂停加载，此时回到调试窗口node-inspector页签，能看到详细的调试信息:  </span><br><span class="line">![<span class="link_label">4</span>](<span class="link_url">http://img4.tbcdn.cn/L1/461/1/13906c6d487121d9374561516034826e7403c9bb</span>)</span><br><span class="line"></span><br><span class="line"><span class="header">#### PS：  </span></span><br><span class="line">在最新的API中，可以将步骤2，4统一为以下命令：</span><br></pre></td></tr></table></figure></p>
<p>$ node-debug index.js<br>```</p>
<h2 id="方式三：使用WebStorm调试Node">方式三：使用WebStorm调试Node</h2><h3 id="1-_配置需调试的Nodejs开发文件夹">1. 配置需调试的Nodejs开发文件夹</h3><p>根据下图依次操作，对需要调试的文件添加配置信息：<br><img src="http://img1.tbcdn.cn/L1/461/1/7e573203efc9c24392125702591f0a1e3d012b6e" alt="5"><br><img src="http://img2.tbcdn.cn/L1/461/1/40c87026f8e03e49e64be369fef0bb5d425fad65" alt="6"><br><img src="http://img1.tbcdn.cn/L1/461/1/62b04edec411bb25c982685617b622ba867bf13d" alt="7">  </p>
<h3 id="2-启动调试并设置断点">2.启动调试并设置断点</h3><p>启动调试：  </p>
<p><img src="http://img1.tbcdn.cn/L1/461/1/ad856a8ac99b06b42193d9fece5d4a40fef1ad60" alt="8">   </p>
<p>将出现调试窗口以及控制台，如下图：  </p>
<p><img src="http://img4.tbcdn.cn/L1/461/1/b3735f9b3b65fe54f671dd4974b6db0e123f1149" alt="9">  </p>
<h3 id="3-在浏览器中访问要调试的页面">3.在浏览器中访问要调试的页面</h3><p>执行到断点位置时，页面会停止加载，可以通过WebStrom的调试窗口看到详细信息：  </p>
<p><img src="http://img1.tbcdn.cn/L1/461/1/e2ed2005b98b4e2519873d36bf20d11f3f9f34b6" alt="10">   </p>

          
        
      </div>
    

    
      <div class="post-footer">
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/05/30/version-control/">
                [翻译]语义化版本管理
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2014-05-30
          
        </span>
        
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <h2 id="摘要">摘要</h2><p>一个完整的版本号分三部分：&lt;主版本号&gt;.&lt;次版本号&gt;.&lt;修订版本号&gt;，版本号的升级原则如下：  </p>
<ol>
<li>主版本号：对API进行了不能兼容原版本的改动。  </li>
<li>次版本号：新增了向后兼容的功能。   </li>
<li>修订版本号：修复了向后兼容的bug。  </li>
</ol>
<p>有关预发布和编译数据的信息可以作为&lt;主版本号&gt;.&lt;次版本号&gt;.&lt;修订版本号&gt;这种版本号格式的扩展。  </p>
<h2 id="简介">简介</h2><p>在软件管理的领域存在着令管理者惧怕的“相依性地狱”，是指随着越来越多的软件包加入系统，系统规模越来越大，管理者越可能在某一天濒临崩溃。  </p>
<p>在相依性高的系统中，发布新版本的软件包可能会很快成为噩梦。如果依赖性过高，将会面临版本锁死的风险（更新一个软件包时必须将其依赖的所有软件包进行更新）。如果依赖关系过于松散，版本号混乱将无法避免（假如将来能够相互兼容的版本数多于合理的数值）。“相依性地狱”即是版本锁死或版本混乱导致项目无法便利地、安全地推进。    </p>
<p>为了解决这个问题，本文提出了一套简单的规则和要求，来规定版本号的分配和升级。这些规则的设定建立在开源和非开源软件都已广泛使用的惯例上，但又不局限于此。为了让系统工作，首先需要声明一套公共API。该API可以由文档构成也可以通过代码来实施。无论如何，该API要清晰明了是最重要的。一旦定义了公共API，API的变化可以通过版本号升级的详细信息来展现。考虑到X.Y.Z（主版本号.次版本号.修订版本号）这样的版本号格式，进行不影响API的bug修复时增加修订版本号，新增或修改向后兼容的API时增加次版本号，进行不向后兼容的API修改时增加主版本号。<br>我称该系统为“语义化版本管理”。在这个体系中，版本号及其升级的方式传达了底层代码的含义以及相邻版本之间的修改内容。  </p>
<h2 id="语义化版本管理规范">语义化版本管理规范</h2><p><a href="http://tools.ietf.org/html/rfc2119" target="_blank" rel="external">RFC 2119</a>对以下文档中的关键词”MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”和”OPTIONAL” 进行了解释。  </p>
<ol>
<li>使用语义化版本管理的软件<strong>必须</strong>声明一套公共API。该API可以在代码中声明，也可以严格地通过文档声明。无论用何种方式声明，API应该是准确和全面的。  </li>
<li>标准的版本号<strong>必须</strong>遵循X.Y.Z的格式，其中X，Y，Z为非负数且<strong>禁止</strong>在头部加0（例如，1.01.3是不允许的）。X是主版本号，Y是次版本号，Z是修订版本号。每一个版本号<strong>必须</strong>以数值形式连续递增。例如：1.9.0-&gt;1.10.0-&gt;1.11.0。  </li>
<li>一旦确定版本号的软件包发布后，禁止再修改该版本的内容，任何的改动<strong>必须</strong>以新版本的形式发布。  </li>
<li>主版本号0（0.y.z）用于初始阶段的开发。不应该认为公共API是稳定的，它随时会发生变化。  </li>
<li>版本号1.0.0定义了公共API。在此版本之后的版本号如何升级依赖于该公共API及其改变方式（例如修复了bug、新增了向后兼容的功能或进行了不兼容的修改）。  </li>
<li>当仅对bug进行了向后兼容的修复时，修订版本号Z（x.y.Z|x&gt;0）<strong>必须</strong>增加。这里所说的bug修复是指针对错误结果进行的内部修改。  </li>
<li>当公共API增加了向后兼容的新功能时，次版本号Y（x.Y.z|x&gt;0）<strong>必须</strong>增加。当弃用公共API中的任何功能时，次版本号也<strong>必须</strong>增加。当私有代码有所改进或引入了大量新功能时（<strong>可能</strong>包含修订版本级别的更改），次版本号<strong>可以</strong>增加。当次版本号增加时修订版本号<strong>必须</strong>重置为0。  </li>
<li>当公共API进行了任何不能向后兼容的改动时（<strong>可能</strong>包含次版本和修订版本级别的更改），主版本号X（X.y.z|X&gt;0）<strong>必须</strong>增加。当主版本号增加时次版本号和修订版本号<strong>必须</strong>重置为0。  </li>
<li><strong>可以</strong>通过在修订版本号后添加一个连字符“-”和一系列以点“.”分割的标识符来表示预发布版本。标识符只能由字母数字和连字符组成，例如[0-9A-Za-z-]。标识符<strong>禁止</strong>为空。标识符中的数字<strong>禁止</strong>在头部加0（例01）。预发布版本的优先级低于相关的正式版本。预发布版本表明该版本还不稳定，或者该版本不像正式版本那样符合了预期的兼容性需求。示例：1.0.0-alpha.1，1.0.0-0.3.7，1.0.0-x.7.z.92。  </li>
<li><strong>可以</strong>通过在修订版本号（或预发布版本号）后添加一个“+”和一系列以“.”分割的标识符来表示编译数据信息。标识符只能由字母数字和连字符构成，例如[0-9A-Za-z-]。标识符<strong>禁止</strong>为空。在确定版本优先级时<strong>应该</strong>忽略编译数据信息。因此，若两个版本号只有编译信息不同，那它们优先级一致。示例：1.0.0-alpha+001，1.0.0+20130313144700，1.0.0-beta+exp.sha.5114f85。  </li>
<li>优先级是指在对版本号进行排序时如何进行对比。计算优先级时<strong>必须</strong>将版本号拆分为主版本号、次版本号、修订版本号和预发布版本号进行排序（编译信息不影响优先级）。通过从左到右的顺序对比主版本号、次版本号和修订版本号时（主版本号、次版本号和修订版本号通常为数字），第一次的差异决定了优先级。例如：1.0.0&lt;2.0.0&lt;2.1.0&lt;2.1.1。主版本号、次版本号和修订版本号一致时，预发布版本号的优先级低于正式版本号。例如：1.0.0-alpha&lt;1.0.0。若两个预发布版本号的主版本号、次版本号和修订版本号一致，优先级<strong>必须</strong>通过以下方式确定：以从左到右的顺序对比由点“.”分割的标识符，直到第一次差异产生。其中标识符的对比规则如下：标识符仅由数字构成时进行数字大小的对比，标识符由字母或字母与数字构成时根据ASCII值逐个对比。非数值型标识符的优先级高于数值型标识符。当前面的标识符相同时，以点“.”分隔的标识符越多优先级越高。例如：1.0.0-alpha&lt;1.0.0-alpha.1&lt;1.0.0-alpha.beta&lt;1.0.0-beta&lt;1.0.0-beta.2&lt;1.0.0-beta.11&lt;1.0.0-rc.1&lt;1.0.0。  </li>
</ol>
<h2 id="为什么使用语义化版本管理">为什么使用语义化版本管理</h2><p>语义化版本管理并不是一个新的或革命性的想法。实际上，你可能已经做了类似的事情。问题是你做的还不够“类似”。如果不遵从某种标准的规范，版本号对于相依性管理实际上是无用的。通过清晰地定义上述方案，软件的使用者更容易理解你的意图。一旦明确了这些意图，最终就能促成灵活的（又不会过于灵活）相依性管理规范。  </p>
<p>通过一个简单的例子可以示范语义化版本管理如何解决“相依性地狱”的问题。假设有一个叫做“消防车”的软件库，它需要一个叫做“梯子”的软件包，且“梯子”已进行了语义化版本管理。在“消防车”被创建时，“梯子”的版本号是3.1.0。由于“消防车”使用的一些功能是首次引入到3.1.0版本的，你可以放心地将相依于“梯子”的版本号指定为3.1.0到4.0.0之间，也可以等于3.1.0。现在，当“梯子”已有3.1.1和3.2.0版本时，可以将它们发布到你的软件包管理系统中，它们兼容现有的相依性软件包。</p>
<p> 作为一个负责的开发者，你当然希望确保软件包的任何升级能像其声明的一样正常运作。现实世界是混乱的，我们能做的只有提高警惕。语义化版本管理是一个明智的选择，让你在发布和升级软件包时无需更新所有依赖的软件包，从而节省时间并省去很多麻烦。<br> 如果你认同这些想法，你只需声明你正在使用语义化版本管理并遵循这些规则。将该网站链接添加到你的README中让其他人了解语义化版本管理的规则并从中受益。  </p>
<h2 id="FAQ">FAQ</h2><p>Q1. 在初始开发阶段0.y.z，应该如何进行版本控制？<br>你要做的就是以0.1.0作为你的初始开发版本号，然后随后的每一次发布都增加次版本号。 </p>
<p>Q2. 我如何判定何时发布版本1.0.0？<br>如果你的软件已上线为产品，那应该已经是版本1.0.0。如果你的API已经稳定且被用户依赖，那也应该是版本1.0.0。如果你很担心向后兼容性，那也应该是1.0.0。   </p>
<p>Q3. 语义化版本管理不会阻碍软件快速开发和迭代吗？<br>主版本号0就是为了快速开发。如果你每天都在更改API，那你应该还处在0.y.z的开发阶段或者在下个主版本的独立开发分支中。    </p>
<p>Q4. 对于公共API，如果进行很细微的不可向后兼容的更改也要增加主版本号，那版本号会不会很快增加到42.0.0？<br>这就牵扯到开发中责任感和前瞻性的问题。对于拥有相依性代码的软件，不应该随意地进行不可向后兼容的更改。升级所要付出的代价可以是巨大的。当不得不增加主版本号来发布不可向后兼容的更改时，意味着你要考虑清楚更改带来的影响并评估相关的成本/收益比率。  </p>
<p>Q5. 用文档声明整个公共API工作量太大！<br>作为一个专业的开发者你有责任编写恰当的文档以便用户使用软件。掌控软件的复杂度对于保持项目高效非常重要，如果没人知道怎么使用你的软件或者不知道哪些方法可以安全调用，那么很难掌控软件的复杂度。长远来看，进行语义化版本管理以及坚持对公共API进行良好的规范能使一切顺利进行。  </p>
<p>Q6. 如果无意中将不可向后兼容的更改当做次版本号进行发布了，该怎么办？<br>一旦意识到违反了语义化版本管理规范，发布一个新的次版本号，该版本修复这个问题并恢复向后兼容。即使在这种情况下，也不能对已发布的版本内容进行修改。恰当的做法是，记录有问题的版本号并告知使用者问题所在。  </p>
<p>Q7. 如果我更新了自己的项目依赖而没有修改公共API，该怎么做？<br>如果没有影响公共API可以认为是向后兼容的修改。如果某一软件与你的软件包有相同的相依性，那它应该有自己的相依性规范并且软件的作者会注意到任何的冲突。在判定更改是属于修订版本号级别还是次版本号级别时，取决于你是为了修复bug还是为了增加新功能而更新了你的相依性。对于后者（增加新功能）通常会增加额外的代码，这显然是一个次版本号级别的升级。  </p>
<p>Q8. 如果我无意中未遵循版本号的变更规则对公共API进行了修改（也就是在进行修订版本等级的发布时，代码错误地进行了主版本级别的修改），怎么办？<br>调动你最佳的判断力。如果按照公共API的意图将修改变更回去会使大量用户群受到强烈影响，那么最好进行一次主版本号级别的发布，尽管严格来讲这次改动只是修订级别的。记住，语义化版本管理的目的就是通过版本号的变更方式传达信息。如果这些变更对用户很重要，那就通过版本号告知用户。  </p>
<p>Q9. 该如何处理弃用的功能？<br>在软件开发中弃用现有的功能是很正常的，而且为了推动开发进程也常常这样做。当你弃用公共API中的部分功能时，你该做以下两件事：（1）升级文档告知用户变更的内容，（2）在适当的时候发布新的次版本号，该版本包含弃用信息。在发布完全移除弃用功能的主版本号之前，至少要发布一次包含弃用信息的次版本号，以便用户能平滑地过渡到新的API。  </p>
<p>Q10. 语义化版本管理对于版本号字符串的长度是否有限制？<br>没有限制。但你要进行判断，例如，一个长为255的版本号字符串就太夸张了。而且，特定的系统可能会限定自己的字符串长度。  </p>
<h2 id="关于">关于</h2><p>原文：<a href="http://semver.org/" target="_blank" rel="external">Semantic Versioning 2.0.0</a><br>语义化版本管理规范是由Gravatars的创办人兼Github共同创办人<a href="http://tom.preston-werner.com/" target="_blank" rel="external">Tom Preston-Werner</a>发起的。<br>如果你有任何建议，请提交至<a href="https://github.com/mojombo/semver/issues" target="_blank" rel="external">GitHub</a>。</p>

          
        
      </div>
    

    
      <div class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/翻译/">
                #翻译
              </a>
            
          </div>
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/04/05/2014-04-05-prototype/">
                对prototype的一些认识
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2014-04-05
          
        </span>
        
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <h2 id="写在前面">写在前面</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">O</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	O.prototype.a=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">var</span> o1=<span class="keyword">new</span> O();</span><br><span class="line">	<span class="keyword">var</span> o2=<span class="keyword">new</span> O();</span><br><span class="line">	o1.a=<span class="number">2</span>;</span><br><span class="line">	alert(o2.a);<span class="comment">//1  </span></span><br><span class="line">```  </span><br><span class="line">`o1.a=<span class="number">1</span>`对`o1`的属性`a`进行重置，对原型中`O.prototype.a`没有任何影响。因此`o2.a`不会变化。根据上述代码可绘制出下图：  </span><br><span class="line">![对prototype的认识](<span class="regexp">/images/</span>prototype.PNG)  </span><br><span class="line">  </span><br><span class="line">## 举例详解  </span><br><span class="line">### 示例一    </span><br><span class="line">```javascript		</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">Obj</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.a=[<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> o1=<span class="keyword">new</span> Obj();</span><br><span class="line">	<span class="keyword">var</span> o2=<span class="keyword">new</span> Obj();</span><br><span class="line">	o1.a.push(<span class="number">2</span>);</span><br><span class="line">	alert(o2.a);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，<code>a</code>是对象<code>Obj</code>的实例属性，每个实例的<code>a</code>属性都是一次拷贝，互不影响。<br><img src="/images/aboutprototype.PNG" alt="对prototype的认识"></p>
<h3 id="示例二">示例二</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Obj</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">Obj.prototype.a=[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> o1=<span class="keyword">new</span> Obj();</span><br><span class="line"><span class="keyword">var</span> o2=<span class="keyword">new</span> Obj();</span><br><span class="line">o1.a.push(<span class="number">2</span>);</span><br><span class="line">alert(o2.a)<span class="comment">//1,2</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，<code>a</code>是对象<code>Obj</code>的原型属性，所有实例都共享<code>a</code>属性，<code>o1.a.push(2);</code>对属性a进行了修改，导致其他实例访问该属性时值已变化。绘图如下：<br><img src="/images/aboutprototype1.PNG" alt="对prototype的认识"></p>
<h3 id="示例三">示例三</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">Obj</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	Obj.prototype.a=[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">var</span> o1=<span class="keyword">new</span> Obj();</span><br><span class="line">	<span class="keyword">var</span> o2=<span class="keyword">new</span> Obj();</span><br><span class="line">	o1.a=[<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">	alert(o2.a);<span class="comment">//1 </span></span><br><span class="line">``` </span><br><span class="line">这个实例跟文章开头那个实例的原理是一样的，`o1.a=[<span class="number">1</span>,<span class="number">2</span>];`重写原型属性`a`使`o1`增加了实例属性`a`，对于`ol`来说这个同名的属性会屏蔽原型中的`a`属性，但是并对=改变原型中的`a`。绘图如下： </span><br><span class="line">![对prototype的认识](<span class="regexp">/images/</span>aboutprototype2.PNG)  </span><br><span class="line">### 示例四  </span><br><span class="line">```javascript  </span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">Obj</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	Obj.prototype.a=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">var</span> o1=<span class="keyword">new</span> Obj();</span><br><span class="line">	Obj.prototype=&#123;a:<span class="number">2</span>&#125;;</span><br><span class="line">	<span class="keyword">var</span> o2=<span class="keyword">new</span> Obj();</span><br><span class="line">	alert(o1.a);<span class="comment">//1</span></span><br><span class="line">	alert(o2.a);<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/aboutprototype3.PNG" alt="对prototype的认识"><br>重写原型前已存在的实例仍指向旧原型，重写原型后新创建的实例指向新原型。  </p>
<h3 id="实例五">实例五</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ObjA</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.a=[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ObjB</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">ObjB.prototype=<span class="keyword">new</span> ObjA();</span><br><span class="line"><span class="keyword">var</span> oa=<span class="keyword">new</span> ObjA();</span><br><span class="line"><span class="keyword">var</span> ob1=<span class="keyword">new</span> ObjB();</span><br><span class="line"><span class="keyword">var</span> ob2=<span class="keyword">new</span> ObjB();</span><br><span class="line">oa.a.push(<span class="number">2</span>);</span><br><span class="line">alert(ob1.a);<span class="comment">//1</span></span><br><span class="line">ob2.a.push(<span class="number">2</span>);</span><br><span class="line">alert(ob1.a);<span class="comment">//1,2</span></span><br></pre></td></tr></table></figure>
<p>这个其实将上面讲到的几个点结合起来了。引用类型<code>a</code>是对象<code>ObjA</code>的实例属性，所以<code>ObjA</code>的两个实例<code>oa</code>和<code>ObjB.prototype</code>各自保存了一个拷贝副本，不会相互影响。因此<code>ob1</code>不受<code>oa.a.push(2);</code>的影响。但对于对象<code>ObjB</code>来讲，<code>a</code>属于原型属性，为<code>ob1</code>和<code>ob2</code>公用。绘图如下：<br><img src="/images/aboutprototype4.PNG" alt="对prototype的认识"></p>

          
        
      </div>
    

    
      <div class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/JS/">
                #JS
              </a>
            
          </div>
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2014/04/05/2014-10-05-prototype/">
                对prototype的一些认识
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2014-04-05
          
        </span>
        
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <h2 id="写在前面">写在前面</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">O</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	O.prototype.a=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">var</span> o1=<span class="keyword">new</span> O();</span><br><span class="line">	<span class="keyword">var</span> o2=<span class="keyword">new</span> O();</span><br><span class="line">	o1.a=<span class="number">2</span>;</span><br><span class="line">	alert(o2.a);<span class="comment">//1  </span></span><br><span class="line">```  </span><br><span class="line">`o1.a=<span class="number">1</span>`对`o1`的属性`a`进行重置，对原型中`O.prototype.a`没有任何影响。因此`o2.a`不会变化。根据上述代码可绘制出下图：  </span><br><span class="line">![对prototype的认识](<span class="regexp">/images/</span>prototype.PNG)  </span><br><span class="line">  </span><br><span class="line">## 举例详解  </span><br><span class="line">### 示例一    </span><br><span class="line">```javascript		</span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">Obj</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.a=[<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> o1=<span class="keyword">new</span> Obj();</span><br><span class="line">	<span class="keyword">var</span> o2=<span class="keyword">new</span> Obj();</span><br><span class="line">	o1.a.push(<span class="number">2</span>);</span><br><span class="line">	alert(o2.a);<span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，<code>a</code>是对象<code>Obj</code>的实例属性，每个实例的<code>a</code>属性都是一次拷贝，互不影响。<br><img src="/images/aboutprototype.PNG" alt="对prototype的认识"></p>
<h3 id="示例二">示例二</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Obj</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">Obj.prototype.a=[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> o1=<span class="keyword">new</span> Obj();</span><br><span class="line"><span class="keyword">var</span> o2=<span class="keyword">new</span> Obj();</span><br><span class="line">o1.a.push(<span class="number">2</span>);</span><br><span class="line">alert(o2.a)<span class="comment">//1,2</span></span><br></pre></td></tr></table></figure>
<p>在上述代码中，<code>a</code>是对象<code>Obj</code>的原型属性，所有实例都共享<code>a</code>属性，<code>o1.a.push(2);</code>对属性a进行了修改，导致其他实例访问该属性时值已变化。绘图如下：<br><img src="/images/aboutprototype1.PNG" alt="对prototype的认识"></p>
<h3 id="示例三">示例三</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">Obj</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	Obj.prototype.a=[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">var</span> o1=<span class="keyword">new</span> Obj();</span><br><span class="line">	<span class="keyword">var</span> o2=<span class="keyword">new</span> Obj();</span><br><span class="line">	o1.a=[<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">	alert(o2.a);<span class="comment">//1 </span></span><br><span class="line">``` </span><br><span class="line">这个实例跟文章开头那个实例的原理是一样的，`o1.a=[<span class="number">1</span>,<span class="number">2</span>];`重写原型属性`a`使`o1`增加了实例属性`a`，对于`ol`来说这个同名的属性会屏蔽原型中的`a`属性，但是并对=改变原型中的`a`。绘图如下： </span><br><span class="line">![对prototype的认识](<span class="regexp">/images/</span>aboutprototype2.PNG)  </span><br><span class="line">### 示例四  </span><br><span class="line">```javascript  </span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">Obj</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	Obj.prototype.a=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">var</span> o1=<span class="keyword">new</span> Obj();</span><br><span class="line">	Obj.prototype=&#123;a:<span class="number">2</span>&#125;;</span><br><span class="line">	<span class="keyword">var</span> o2=<span class="keyword">new</span> Obj();</span><br><span class="line">	alert(o1.a);<span class="comment">//1</span></span><br><span class="line">	alert(o2.a);<span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/aboutprototype3.PNG" alt="对prototype的认识"><br>重写原型前已存在的实例仍指向旧原型，重写原型后新创建的实例指向新原型。  </p>
<h3 id="实例五">实例五</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ObjA</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.a=[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ObjB</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">ObjB.prototype=<span class="keyword">new</span> ObjA();</span><br><span class="line"><span class="keyword">var</span> oa=<span class="keyword">new</span> ObjA();</span><br><span class="line"><span class="keyword">var</span> ob1=<span class="keyword">new</span> ObjB();</span><br><span class="line"><span class="keyword">var</span> ob2=<span class="keyword">new</span> ObjB();</span><br><span class="line">oa.a.push(<span class="number">2</span>);</span><br><span class="line">alert(ob1.a);<span class="comment">//1</span></span><br><span class="line">ob2.a.push(<span class="number">2</span>);</span><br><span class="line">alert(ob1.a);<span class="comment">//1,2</span></span><br></pre></td></tr></table></figure>
<p>这个其实将上面讲到的几个点结合起来了。引用类型<code>a</code>是对象<code>ObjA</code>的实例属性，所以<code>ObjA</code>的两个实例<code>oa</code>和<code>ObjB.prototype</code>各自保存了一个拷贝副本，不会相互影响。因此<code>ob1</code>不受<code>oa.a.push(2);</code>的影响。但对于对象<code>ObjB</code>来讲，<code>a</code>属于原型属性，为<code>ob1</code>和<code>ob2</code>公用。绘图如下：<br><img src="/images/aboutprototype4.PNG" alt="对prototype的认识"></p>

          
        
      </div>
    

    
      <div class="post-footer">
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2013/10/03/2013-10-03-number-and-string/">
                js中数值和字符串的一点事儿
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2013-10-03
          
        </span>
        
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <h2 id="写在前面">写在前面</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="string">"10"</span> &lt; <span class="string">"9"</span>);<span class="comment">//true</span></span><br><span class="line">alert(<span class="string">"10"</span> &lt; <span class="string">"c"</span>);<span class="comment">//true</span></span><br><span class="line">alert(<span class="number">10</span> &lt; <span class="string">"9"</span>);<span class="comment">//false</span></span><br><span class="line">alert(<span class="number">10</span> &lt; <span class="string">"11c"</span>);<span class="comment">//false</span></span><br><span class="line">alert(<span class="number">10</span> &gt; <span class="string">"11c"</span>);<span class="comment">//false</span></span><br><span class="line">alert(+<span class="string">"10"</span> &lt; <span class="string">"9"</span>);<span class="comment">//false</span></span><br><span class="line">alert(+<span class="string">"10"</span> &gt; <span class="number">9</span>);<span class="comment">//true  </span></span><br><span class="line"> alert(-<span class="string">"10"</span>&lt;<span class="number">9</span>);<span class="comment">//true</span></span><br><span class="line">alert(<span class="string">"-10"</span>&lt;<span class="number">9</span>);<span class="comment">//true </span></span><br><span class="line">alert(<span class="string">""</span> &lt; <span class="number">1</span>);<span class="comment">//true</span></span><br><span class="line">   alert(<span class="built_in">parseInt</span>(<span class="string">""</span>) &lt; <span class="number">1</span>); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>有让你觉得意外的地方么~  </p>
<h2 id="数值、字符串大小比较">数值、字符串大小比较</h2><ul>
<li>字符串之间：这个比较简单，逐个字符进行比较ASCII码值。  </li>
<li><p>字符串与数值之间：将<strong>字符串转换数值</strong>，然后比较数值大小。  </p>
<pre><code class="javascript">alert(<span class="number">10</span> &lt; <span class="string">"11c"</span>);<span class="comment">//false</span>
alert(<span class="number">10</span> &gt; <span class="string">"11c"</span>);<span class="comment">//false</span>
</code></pre>
<p>上述代码两次均返回<code>false</code>，这是由于<code>&quot;11c&quot;</code>不能转化为数值。可以测试<code>isNaN(&quot;11c&quot;)</code>返回<code>true</code>。<br><strong>数值与<code>NaN</code>比较大小永远返回<code>false</code>。</strong><br>需要注意的是，此处字符串转换为数值的规则<strong>与<code>parseInt()</code>是不相同的</strong>。此处的规则与<code>Number()</code>和<code>isNaN()</code>是一致的，规则如下:    </p>
<ul>
<li><p>若字符串只包含数字、正号<code>+</code> 和负号<code>-</code>，转化为十进制。例如：           </p>
<pre><code>alert(+<span class="string">"10"</span> &gt; <span class="number">9</span>);<span class="comment">//true 即(10&lt;9) </span>
 alert(+<span class="string">"10&gt;"</span><span class="number">9</span><span class="string">");//true 即(10&gt;9)</span>
   alert(-<span class="string">"10"</span>&lt;<span class="number">9</span>);<span class="comment">//true 即(-10&lt;9)</span>
  alert(<span class="string">"-10"</span>&lt;<span class="number">9</span>);<span class="comment">//true 即(-10&lt;9)  </span>
</code></pre></li>
<li>若包含有效的浮点格式，例如2.1，则转化为响应的浮点数  </li>
<li>若为空字符串，则转换为0  </li>
<li><p>若包含<code>0x</code>则转换为十六进制，若包含<code>0</code>则不按照八进制解析而忽略头部的任意多个0；  </p>
<pre><code><span class="function"><span class="title">alert</span><span class="params">(<span class="string">"011"</span>&lt;<span class="number">9</span>)</span></span><span class="comment">//false 即(11&lt;9)  </span>
<span class="function"><span class="title">alert</span><span class="params">(<span class="string">"0x11"</span>&lt;<span class="number">15</span>)</span></span><span class="comment">//false 即(17&lt;15)</span>
</code></pre></li>
<li><p>若包含以上格式其他字符，则返回<code>NaN</code>，例如  </p>
<pre><code>alert(<span class="number">10</span> &lt; <span class="string">"11c"</span>);<span class="comment">//false 即(10&lt;NaN)</span>
   alert(<span class="number">10</span> &gt; <span class="string">"11c"</span>);<span class="comment">//false 即(10&gt;NaN)</span>
</code></pre></li>
</ul>
</li>
</ul>
<h2 id="parseInt()工作原理">parseInt()工作原理</h2><h3 id="parseInt(string,radix)用法：">parseInt(string,radix)用法：</h3><ul>
<li>返回值是十进制；</li>
<li>无视<code>string</code>中最前和最后的空格；   </li>
<li>参数<code>radix</code>是指解析<code>string</code>的进制，若未指定<code>radix</code>或值为0则按默认进制对<code>string</code>进行解析；  </li>
<li><p>未指定<code>radix</code>的情况下，若<code>string</code>的首字符为<code>0</code>，则按照八进制进行解析；若<code>string</code>的首字符为<code>0x</code>则默认按照十六进制解析<code>string</code>，其他情况默认为十进制；    </p>
<pre><code><span class="built_in">parseInt</span>(<span class="string">"011"</span>);<span class="comment">//9</span>
<span class="built_in">parseInt</span>(<span class="string">"0x11"</span>);<span class="comment">//17</span>
</code></pre></li>
<li><p>解析从第一个字符开始，到第一个不能解析的字符（空格、英文、标点等）结束；<strong>重点说一下，能解析的字符包括数字、正号<code>+</code>和负号<code>-</code>；</strong>    </p>
<pre><code><span class="built_in">parseInt</span>(<span class="string">"1a"</span>);<span class="comment">//1</span>
<span class="built_in">parseInt</span>(<span class="string">""</span>);<span class="comment">//NaN</span>
<span class="built_in">parseInt</span>(<span class="string">"-1"</span>);<span class="comment">//-1</span>
</code></pre></li>
<li><p>若第一个字符就不能解析，则返回NaN；  </p>
</li>
</ul>
<p>实例一：   </p>
<pre><code><span class="keyword">var</span> <span class="built_in">c</span> = parseInt(<span class="string">"017/08/2009"</span>);
alert(<span class="built_in">c</span>);               <span class="comment">//15</span>
</code></pre><p>解析：未指定radix，第一个字符为0，则按照八进制进行解析，且解析到7停止，017输出15。  </p>
<p>实例二：  </p>
<pre><code><span class="keyword">var</span> <span class="keyword">d</span> = parseInt(<span class="string">"09/08/2009"</span>);
alert(<span class="keyword">d</span>);              <span class="comment">//0</span>
</code></pre><p>解析：未指定radix，第一个字符为0，<strong>按照八进制解析时9属于不能解析的字符</strong>，故0输出0.</p>
<h2 id="Number()和parseInt()区别（实例）">Number()和parseInt()区别（实例）</h2><pre><code><span class="built_in">Number</span>(<span class="string">"1a"</span>);<span class="comment">//null</span>
<span class="built_in">parseInt</span>(<span class="string">"1a"</span>);<span class="comment">//1</span>

<span class="built_in">Number</span>(<span class="string">""</span>);<span class="comment">//0</span>
<span class="built_in">parseInt</span>(<span class="string">""</span>);<span class="comment">//NaN</span>

<span class="built_in">Number</span>(<span class="string">"011"</span>);<span class="comment">//11</span>
<span class="built_in">parseInt</span>(<span class="string">"011"</span>);<span class="comment">//9</span>
</code></pre>
          
        
      </div>
    

    
      <div class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/JS/">
                #JS
              </a>
            
          </div>
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  
    

  <div class="post post-type-normal ">
    <div class="post-header">

      
      
        <h1 class="post-title">
          
          
            
              <a class="post-title-link" href="/2013/10/03/2013-10-03-a-button-by-css3/">
                用CSS3实现一个按钮
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          
            发表于 2013-10-03
          
        </span>
        
          
        
      </div>
    </div>

    
      <div class="post-body">

        
        

        
          
            <h2 id="写在前面">写在前面</h2><p><img src="../images/btnstep4.PNG" alt="css3实现一个小按钮"><br>看到知乎上的一个小按钮，类似上图。<br>当然，你可以使用背景图片，那样能够跨多浏览器，但是适应性不好；如果想应对宽和高不固定的情况，可能需要使用“滑动门”。<br>今天想使用CSS3多个属性结合实现一下。  </p>
<h2 id="实现">实现</h2><h3 id="分析">分析</h3><p>上图按钮有这么几个特点：  </p>
<ul>
<li>圆角  </li>
<li>上方有高光  </li>
<li>有渐变营造出凸起的立体效果    </li>
</ul>
<h3 id="分步实现">分步实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.invite&#123;</span><br><span class="line">	min-width:<span class="number">75</span>px;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&lt;button <span class="keyword">class</span>=<span class="string">"invite"</span>&gt;邀请回答&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="../images/btnstep1.png" alt="css3实现一个小按钮"></p>
<h4 id="step1:圆角">step1:圆角</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.invite&#123;</span><br><span class="line">	min-width:<span class="number">75</span>px;</span><br><span class="line">	height:<span class="number">25</span>px;</span><br><span class="line">       <span class="comment">/*圆角*/</span></span><br><span class="line">       border:<span class="number">1</span>px solid #<span class="number">0063</span>B8;</span><br><span class="line">       border-radius:<span class="number">4</span>px;</span><br><span class="line">       -webkit-border-radius:<span class="number">4</span>px;</span><br><span class="line">       -moz-border-radius:<span class="number">4</span>px;</span><br><span class="line">       -o-border-radius:<span class="number">4</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="../images/btnstep2.png" alt="css3实现一个小按钮">  </p>
<h4 id="step2:高光">step2:高光</h4><p>给<code>button</code>添加盒内阴影，颜色设置比边框稍浅<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">	.invite&#123;</span><br><span class="line">            min-width:<span class="number">75</span>px;</span><br><span class="line">            height:<span class="number">25</span>px;</span><br><span class="line">            <span class="comment">/*圆角*/</span></span><br><span class="line">            border:<span class="number">1</span>px solid #<span class="number">0063</span>B8;</span><br><span class="line">            border-radius:<span class="number">4</span>px;</span><br><span class="line">            -webkit-border-radius:<span class="number">4</span>px;</span><br><span class="line">            -moz-border-radius:<span class="number">4</span>px;</span><br><span class="line">            -o-border-radius:<span class="number">4</span>px;</span><br><span class="line">            <span class="comment">/*高光*/</span></span><br><span class="line">            box-shadow:inset <span class="number">0</span> <span class="number">1</span>px <span class="number">0</span> <span class="number">0</span> #<span class="number">349</span>ED6;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">```  	</span><br><span class="line">![css3实现一个小按钮](../images/btnstep3.png)   </span><br><span class="line">  </span><br><span class="line">#### step3：纵向渐变  </span><br><span class="line">纵向渐变，渐变开始的颜色最好比高光设置颜色深且比边框颜色浅。    </span><br><span class="line">```javascript</span><br><span class="line">	.invite&#123;</span><br><span class="line">            min-width:<span class="number">75</span>px;</span><br><span class="line">            height:<span class="number">25</span>px;</span><br><span class="line">            <span class="comment">/*圆角*/</span></span><br><span class="line">            border:<span class="number">1</span>px solid #<span class="number">0063</span>B8;</span><br><span class="line">            border-radius:<span class="number">4</span>px;</span><br><span class="line">            -webkit-border-radius:<span class="number">4</span>px;</span><br><span class="line">            -moz-border-radius:<span class="number">4</span>px;</span><br><span class="line">            -o-border-radius:<span class="number">4</span>px;</span><br><span class="line">            <span class="comment">/*高光*/</span></span><br><span class="line">            box-shadow:inset <span class="number">0</span> <span class="number">1</span>px <span class="number">0</span> <span class="number">0</span> #<span class="number">349</span>ED6;</span><br><span class="line">            <span class="comment">/*纵向渐变造成凸出效果*/</span>  </span><br><span class="line">            background:#<span class="number">01539</span>A;</span><br><span class="line">            background-image:-webkit-gradient(linear,<span class="number">0</span>% <span class="number">0</span>%,<span class="number">0</span>% <span class="number">100</span>%,from(#<span class="number">0084</span>CC),to(#<span class="number">01539</span>A));</span><br><span class="line">            color:White;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="../images/btnstep4.png" alt="css3实现一个小按钮"><br>上述代码设置<code>background:#01539A;</code>是为了使按钮在不支持渐变的浏览器下仍有背景。</p>

          
        
      </div>
    

    
      <div class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/CSS/">
                #CSS
              </a>
            
          </div>
        

        

        
        
          <div class="post-eof"></div>
        
      </div>
    
  </div>


  

          </div>

          
            <div class="pagination">
              <a class="extend prev" rel="prev" href="/">&laquo;</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">&raquo;</a>
            </div>
          
        </div>

        
<div class="sidebar-toggle">
  <div class="sidebar-toggle-line-wrap">
    <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
    <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
  </div>
</div>

<div id="sidebar" class="sidebar">
  <div class="sidebar-inner">

    

    <div class="site-overview">
      <div class="site-author motion-element">
        <img class="site-author-image" src="/images/default_avatar.jpg" alt="Chen Zhang" />
        <p class="site-author-name">Chen Zhang</p>
      </div>
      <p class="site-description motion-element"></p>
      <div class="site-state motion-element">
        <div class="site-state-item site-state-posts">
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </div>
        <div class="site-state-item site-state-tags">
            <span class="site-state-item-count">6</span>
            <span class="site-state-item-name">标签</span>
        </div>
        <div class="site-state-item site-state-pages">
            <span class="site-state-item-count">1</span>
            <span class="site-state-item-name">页面</span>
        </div>
      </div>

      

      <div class="social-info motion-element">
        
      </div>

      
      

    </div>

    

  </div>
</div>


      </div>
    </div>

    <div id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; &nbsp; 
  2015
  <span class="with-love">
    <i class="icon-heart"></i>
  </span>
  <span class="author">Chen Zhang</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT</a>
</div>



      </div>
    </div>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript">
    $(document).ready(function() {
      $(".fancybox").fancybox();
    });
  </script>

  <script type="text/javascript">
  function hasMobileUA () {
    var nav = window.navigator;
    var ua = nav.userAgent;
    var pa = /iPad|iPhone|Android|Opera Mini|BlackBerry|webOS|UCWEB|Blazer|PSP|IEMobile|Symbian/g;

    return pa.test(ua);
  }

  function isDesktop () {
    return screen.width > 991 && !hasMobileUA();
  }

  function isTablet () {
    return screen.width < 992 && screen.width > 767 && hasMobileUA();
  }

  function isMobile () {
    return screen.width < 767 && hasMobileUA();
  }

  function escapeSelector (selector) {
    return selector.replace(/[!"$%&'()*+,.\/:;<=>?@[\\\]^`{|}~]/g, "\\$&")
  }
</script>

  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  
  <script type="text/javascript" id="motion.page.home">
    $(document).ready(function () {
      $.Velocity.RunSequence([
        { e: $('.brand'), p: { opacity: 1 }, o: { duration: 100 } },
        { e: $('.logo'), p: { opacity: 1, top: 0 }, o: { duration: 50} },
        { e: $('.site-title'), p: { opacity: 1, top: 0 }, o: { duration: 200, sequenceQueue: false } }
      ]);
      $('.menu-item').velocity('transition.slideDownIn', {display: null});
    });
  </script>


  <script type="text/javascript" id="motion.global">
  $(document).ready(function () {
    var body = $('body');
    var isSidebarVisible = false;
    var sidebarToggle = $('.sidebar-toggle');
    var sidebarToggleLine1st = $('.sidebar-toggle-line-first')
    var sidebarToggleLine2nd = $('.sidebar-toggle-line-middle');
    var sidebarToggleLine3rd = $('.sidebar-toggle-line-last');
    var sidebar = $('.sidebar');

    var SIDEBAR_WIDTH = '320px';
    var SIDEBAR_DISPLAY_DURATION = 300;

    var sidebarToogleLineStatusInit = {width: '100%', opacity: 1, left: 0, rotateZ: 0, top: 0};

    var sidebarToggleLine1stStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine1stStatusArrow = {width: '50%', rotateZ: '-45deg', top: '2px'};
    var sidebarToogleLine1stStatusClose = {width: '100%', rotateZ: '-45deg', top: '5px'};

    var sidebarToggleLine2ndStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine2ndStatusArrow = {width: '90%'};
    var sidebarToogleLine2ndStatusClose = {opacity: 0};

    var sidebarToggleLine3rdStatusInit = sidebarToogleLineStatusInit;
    var sidebarToggleLine3rdStatusArrow = {width: '50%', rotateZ: '45deg', top: '-2px'};
    var sidebarToogleLine3rdStatusClose = {width: '100%', rotateZ: '45deg', top: '-5px'};

    sidebatToggleMotion();
    postsListMotion();
    backToTopMotion();


    $(document)
      .on('sidebar.isShowing', function () {
        isDesktop() && body.velocity(
          {paddingRight: SIDEBAR_WIDTH},
          SIDEBAR_DISPLAY_DURATION
        );
        sidebarContentMotion();
      })
      .on('sidebar.isHiding', function () {});


    function backToTopMotion () {
      var b2top = $('.back-to-top');
      b2top.on('click', function () {
        body.velocity('scroll');
      });
    }

    function sidebarShowMotion () {

      sidebarToggleLine1st.velocity(sidebarToogleLine1stStatusClose);
      sidebarToggleLine2nd.velocity(sidebarToogleLine2ndStatusClose);
      sidebarToggleLine3rd.velocity(sidebarToogleLine3rdStatusClose);

      sidebar.velocity({width: SIDEBAR_WIDTH}, {
        display: 'block',
        duration: SIDEBAR_DISPLAY_DURATION,
        complete: function () {
          sidebar.addClass('sidebar-active');
          sidebar.trigger('sidebar.didShow');
        }
      });
      sidebar.trigger('sidebar.isShowing');
    }

    function sidebarHideMotion () {
      isDesktop() && body.velocity({paddingRight: 0});
      sidebar.velocity('reverse');

      sidebarToggleLine1st.velocity(sidebarToggleLine1stStatusInit);
      sidebarToggleLine2nd.velocity(sidebarToggleLine2ndStatusInit);
      sidebarToggleLine3rd.velocity(sidebarToggleLine3rdStatusInit);

      sidebar.removeClass('sidebar-active');
      sidebar.trigger('sidebar.isHiding');
    };

    function sidebarContentMotion () {
      $('.sidebar .motion-element').velocity(
        'transition.slideRightIn',
        {stagger: 50, drag: true}
      );
    }

    function postsListMotion () {
      var postMotionOptions = postMotionOptions || {stagger: 300, drag: true};
      $('.post').velocity('transition.slideDownIn', postMotionOptions);
    }

    function sidebatToggleMotion () {
      sidebarToggle.on('click', function () {
        isSidebarVisible ? sidebarHideMotion() : sidebarShowMotion();
        isSidebarVisible = !isSidebarVisible;
      });

      sidebarToggle.hover(function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusArrow);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusArrow);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusArrow);
      }, function () {
        if (isSidebarVisible) {return}
        sidebarToggleLine1st.velocity('stop').velocity(sidebarToggleLine1stStatusInit);
        sidebarToggleLine2nd.velocity('stop').velocity(sidebarToggleLine2ndStatusInit);
        sidebarToggleLine3rd.velocity('stop').velocity(sidebarToggleLine3rdStatusInit);
      });
    }
  });

</script>





  

  

  
  

  


  
</body>
</html>
